Хочу рассказать про PieceofScript - простой язык для сценариев автоматического тестирования HTTP JSON API.

Что на текущий момент может PieceofScript:<ul>
	<li>описывать методы API в формате yaml, с названием метода на почти естественном языке, что удобно для чтения тестов</li>
	<li>достаточно гибко описывать модели в формате yaml и генерировать по ним рандомные данные</li>
	<li>писать сложные сценарии вызовов API на легкочитаемом языке с несложным синтаксисом</li>
	<li>получать результаты тестирования в формате JUnit (Jenkins, например, понимает), и в HTML</li>
</ul>
По сути это очередной "велосипед". Мотивация для написания была банальна: меня вгонял в уныние используемый в компании SoapUI. Хотелось просто и понятно описывать тесты в текстовом редакторе без специального GUI, даже если это приятный интерфейс Postman. Кроме того, огромный xml-файл, который выдает SoapUI, довольно плохо "переваривается" git'ом, и тесты на конкретную задачу сложно положить в той же ветке, где сделана сама задача. Я немного изучил другие инструменты тестирования, у каждого был "<a href="http://lurkmore.to/%D0%A4%D0%B0%D1%82%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BE%D0%BA">фатальный недостаток</a>", поэтому я в припадке <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D0%B4%D1%80%D0%BE%D0%BC_%D0%BD%D0%B5%D0%BF%D1%80%D0%B8%D1%8F%D1%82%D0%B8%D1%8F_%D1%87%D1%83%D0%B6%D0%BE%D0%B9_%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8">NIH-синдрома</a> открыл IDE.

Расскажу подробнее что из этого вышло. Поехали!

<img src="https://habrastorage.org/webt/be/su/_o/besu_olm_gbromxnr34mzcvy8sy.gif" />
<cut />

Интерпретатор написан на PHP и представляет собой phar-архив, требует версию PHP 7.1 или выше. 7.3, конечно, приятнее, но хотелось большей совместимости, и при этом не опускаться до "пятерки". Исходный код и документация доступны тут https://github.com/maximw/PieceofScript. Документация в разработке. Это, как оказалось, самая трудная и нудная часть.

<a href="#struct">Проект тестирования, его cтруктура и запуск</a>
<a href="#script">Сценарий тестирования</a>
<a href="#methods">Методы тестируемого API</a>
<a href="#call">Вызов метода API</a>
<a href="#generators">Генерация моделей и тестовых данных</a>
<a href="#functions">Встроенные функции</a>
<a href="#testcases">Тест-кейсы</a>
<a href="#vars">Переменные и области видимости</a>
<a href="#types">Типы и операции</a>
<a href="#storage">Сохранение данных между запусками</a>
<a href="#output">Вывод в stdout</a>
<a href="#examples">Примеры</a> - хватит слов, покажи код!
<a href="#plans">Замечания и планы на будущее, если оно будет</a>

<anchor>struct</anchor><h2>Проект тестирования, его cтруктура и запуск</h2>
Проект представляет собой директорию с набором файлов-сценариев, файлов описания методов API и генераторов тестовых данных.
В минимальной версии проект выглядит так:
<source>./tests
  endpoints.yaml        - Методы API
  generators.yaml       - Генераторы
  start.pos             - Стартовый сценарий тестирования</source>
Стартовый файл - это сценарий с которого начинается процесс тестирования. Он задается при запуске:
<source lang="bash">pos.phar run ./start.pos --junit=result_in_junit_format.xml -vvv --config=config.yaml</source>
Все относительные пути считаются от рабочей директории, содержащей стартовый файл.
Конфигурационный файл можно задать в командной строке опцией <i>--config</i> или положить <i>config.yaml</i> в рабочую директорию. Конфиг не обязателен, туда нужно лезть по необходимости. <a href="https://github.com/maximw/PieceofScript/blob/master/docs/usage.md">Подробнее про конфиг</a>.


<anchor>script</anchor><h2>Сценарий тестирования</h2>
Для себя решил писать сценарии в файлах с расширением .pos, чтоб можно было сделать настройки подсветки кода в IDE с привязкой по расширению. Но интерпретатору совершенно безразлично расширение.

Вот простой пример сценария для воображаемого форума, где выполняется тест создания и прочтения поста разными пользователями.
<source lang="php">require "./globals.pos" // Здесь определим глобальные переменные, например $domain
include "./globals_local.pos" // Здесь можно переопределить глобальные переменные, для другого окружения
include "./user/*.pos" // Подключаем все файлы что найдем в ./user и ./post
include "./post/*.pos"

// Сгенерируем несколько моделей пользователей и поста
var $author = User()
var $reader = User()
var $banned = User()
var $post = Post()

Register $author // Вызов метода API, который регистрирует переданного пользователя
must $response.code == 201 // Регистрация должна пройти успешно
Register $reader
must $response.code == 201
Register $banned
must $response.code == 201
Add $banned to blacklist of $author //$banned больше не может видеть посты $author

Create post $post by $author // Вызов метода API создания поста
must $response.code == 201 // Проверка что метод API ответил кодом 201
// ...и, на всякий случай, что содержимое созданного поста не изменилось
assert $response.body.post.content == $post.content
var $postId = $response.body.post.id // Id созданного поста еще пригодится

Read post $postId by $author // Прочитать пост самим автором
must $response.code == 200
assert $response.body.post.content == $post.content

Read post $postId by $reader // И прочитать пост другим пользователем
must $response.code == 200
assert $response.body.post.content == $post.content

Read post $postId by $banned // А для этого пост будет не найден
assert $response.code == 404
</source>
Да, без подсветки выглядит не очень.

Каждая выполнимая строка сценария начинается с оператора, либо является вызовом метода API. Если вдруг имя метода API начинается со слова совпадающего с одним из операторов, можно использовать символ "<i>></i>":
<source>>Include $user to group $userGroup</source>
Операторы регистронезависимы. assert, ASSERT или aSsErT (но зачем так писать?) будут работать.
Каждый оператор или вызов метода API должны находиться на отдельной строке. Но возможен и перенос строк, если последний символ строки <i>\</i> (привет, Python).
<spoiler title="Неинтересные подробности про переносы строк и отступы">
Если перенос строки  использовать в комментарии, то следующая строка будет тоже считаться частью комментария. При переносе строк внутри блоков (<i>testcase</i>, <i>if</i>, <i>while</i>, <i>foreach</i>) важно соблюдать отступы, чтоб следующая строка попала в тот же блок.
<source lang="code">var $n = 20
var $i = 2
var $fib1 = 1; \
    $fib2 = 1
while $i <= $n
    var $fib_sum = \
        $fib2 + $fib1
    print toString($i) + " число Фиббоначи:" + \
        toString($fib_sum)
    var $fib1 = $fib2
    var $fib2 = $fib_sum
    var $i = $i + 1</source>
При выполнении блочных операторов (<i>testcase</i>, <i>if</i>, <i>while</i>, <i>foreach</i>) блок определяется отступами его строк. Отступ считается как количество пробельных символов в начале строки. И пробел, и табуляция считаются за один символ, но табуляция обычно отображается в редакторах как несколько пробелов. Поэтому для избежания неразберихи лучше использовать или табы, или пробелы, но не все вместе.
</spoiler>

<h4>Полный список операторов:</h4>
<b>require <i>fileName</i></b> - подключить файл в место вызова оператора. Тут же начнет выполняться подключенный файл с первой его строки. По завершению выполнения, интерпретатор вернется к следующей строке исходного файла. Если запрашиваемый файл не доступен для чтения, то будет выдана ошибка. Относительный путь считается от рабочей директории.

<b>include <i>fileMask</i></b> - аналогично require, но если запрашиваемый файл не доступен для чтения, то ошибки не будет. Это удобно, например, для создания настроек для разных окружений тестирования. Кроме того, include умеет подключать сразу все файлы по маске. Так, например, можно загрузить целые директории файлов, содержащих тесткейсы. Но при этом не гарантируется какая-либо очередность загрузки файлов.

<b>var <i>$variable1 = expression1</i>; <i>$variable2 = expression2</i>; ... ; <i>$variableN = expressionN</i></b> - присвоить значения переменным. Если переменной еще нет, она будет создана в текущем контексте.

<b>let <i>$variable1 = expression1</i>; <i>$variable2 = expression2</i>; ... ; <i>$variableN = expressionN</i></b> - присвоить значения переменным. Если переменной нет в текущем контексте, будет попытка создать или изменить переменную в глобальном контексте.

<b>const <i>$const1 = expression1</i>; <i>$const2 = expression2</i>; ... ; <i>$constN = expressionN</i></b> - установить значение констант в текущем контексте. Отличие констант от переменных только в том, что их нельзя изменять, при попытке присвоить значение константе после объявления будет выдано предупрежение. Eсли уже есть переменная с таким именем, то при попытке объявить ее константой будет выдана ошибка. В остальном все что справедливо для переменных, справедливо и для констант.

<b>import <i>$variable1</i>; <i>$variable2</i>; ... ;<i>$variableN</i></b> - копирует переменные из глобального в текущий контекст. Может пригодиться, если надо оперировать со значением глобальной переменной, но не изменить его.

<b>testcase <i>testCaseName</i></b> - объявляет тест-кейс, который потом можно вызвать как единое целое оператором <i>run</i>. Подробнее про <a href="#testcases">тест-кейсы</a> далее.

<b>assert <i>expression</i></b> - проверить что выражение <i>expression</i> равно <i>true</i>, в противном случае вывести отчет о провалившемся тесте.

<b>must <i>expression</i></b> - то же самое, что и <i>assert</i>, только в случае провала теста, выполнение текущего тест-кейса будет прекращено, а вне контекста тест-кейса будет вообще прекращено дальнейшее выполнение сценария. Может использоваться, если поймана ошибка, с которой дальнейшие проверки не имеют смысла.

<b>run <i>testCaseName</i></b> - запустить на выполнение заданный тест-кейс. <i>run </i> без указания имени тест-кейса запустит все объявленные тест-кейсы, не требующие аргументов, в порядке их объявления.

<b>while <i>expression</i></b> - цикл, пока <i>expression</i> истинно, выполняет операторы с отступом строки больше чем у <i>while</i>.

<b>foreach <i>$array</i>; <i>$element</i></b> - цикл прохода по массиву, тело цикла выполняется для каждого очередного элемента массива. Возможно получение еще и ключа <b>foreach <i>$array</i>; <i>$key</i>; <i>$element</i></b>. Переменные <i>$key</i> и <i>$element</i> создаются/перезаписываются в текущем контексте.

<b>if <i>expression</i></b> - если <i>expression</i> истинно, выполняет операторы с отступом строки больше чем у <i>if</i>

<b>print <i>expression1</i>; <i>expression2</i>; ... <i>expressionN</i></b> - вывести значение выражениях <i>expressionM</i> в stdout. Может использоваться для отладки, работает только с уровнем "болтливости" <i>--verbosity=1</i> или <i>-v</i> и больше.

<b>sleep <i>expression</i></b> - сделать паузу на заданное число, необязательно целое, секунд. Иногда надо дать тестируемому API передышку.

<b>pause <i>expression</i></b> - не в интерактивном режиме (опция командной строки <i>-n</i>) аналогичен <i>sleep</i>. <i>Expression</i> не обязательно, в этом случае паузы не будет. А в интерактивном режиме сделать паузу до нажатия Enter.

<b>cancel</b> - закончить тестирование. Интерпретатор заканчивает работу, создает отчеты.

<anchor>methods</anchor><h2>Методы тестируемого API</h2>
Это собственно то, что надо тестировать - вызывать с определенными параметрами и проверять соответствует ли ответ ожиданиям.
Методы API описываются в формате yaml. По умолчанию, описания должны находиться в файле <i>endpoints.yaml</i> текущей директории и/или в файлах <i>*.yaml</i> в ее поддиректории <i>./endpoints</i>. Перед тестированием интерпретатор попытается вычитать сразу все эти файлы.

Пример структуры <i>endpoints.yaml</i>:
<source lang="yaml">Auth $user:
    method: "POST"
    url: $domain + "/login"
    headers:
        Content-Type: "application/json"
    format: "json"
    data:
        login: $user.login
        password: $user.password
    after:
        - assert $response.code == 200
        - let $user.auth_token = $response.body.auth_token

Create post $post by $user:
    method: "POST"
    url: $domain + "/posts"
    format: "json"
    data: $post
    headers:
        auth: "Bearer " + $user.auth_token
        content-type: "application/json"
    after:
        - assert $response.code == 201

Read post $postId by $user:
    method: "GET"
    url: $domain + "/posts/" + $postId
    headers:
        auth: "Bearer " + $user.auth_token
        content-type: "application/json"
    after:
        - assert ($response.code == 200) || ($response.code == 404)

Create comment $comment on $post by $user:
    method: "POST"
    url: $domain + "/comments/create/" + $post.id
    format: "json"
    data: $comment
    headers:
        auth: "Bearer " + $user.auth_token
        content-type: "application/json"
    after:
        - assert $response.code == 201
</source>
Имя метода API (верхний уровень структуры yaml), по которому он может быть вызван, представляет собой строку в почти произвольном формате.

В любом месте имени могут быть указаны аргументы. Они должны быть отделены пробелами от остальных слов. Например <i>$comment</i>, <i>$post</i> и <i>$user</i> в последнем методе.

Так же в любом месте имени можно указать опциональные значения метода в двойных фигурных скобках.
<source>Get comments of $post {{$page=1; $perPage=20}}:
    method: "GET"
    url: $domain + "/comments/" + $post.id
    query:
        page: $page
        per_page: $perPage
    headers:
        auth: "Bearer " + $user.auth_token
        content-type: "application/json"
    after:
        - assert $response.code == 200	</source>
В выражениях, задающих опциональные значения, доступны переменные глобального контекста.
Опциональные значения могут быть полезны, чтоб каждый раз не указывать их при вызове метода API. Если размер страницы требуется изменить только в одном месте, зачем указывать его во всех остальных тестах?! Примеры вызовов этого метода:
<source>Get comments of $newPost
Get comments of $newPost {{$page=$currentPage+1}}
Get comments of {$newPost} {{$perPage=10;$page=100}}
</source>

Остальные, используемые переменные (<i>$domain</i> в примере выше) будут взяты из глобального контекста. Подробнее <a href="#contexts">про контексты</a> расскажу дальше.

Мне кажется, удобно давать методам API человеко-понятные имена на естественном языке, тогда сценарий тестирования легче читать. Имена регистронезависимы, т.е метод <i>Auth $User</i> может быть вызван как <i>auth $User</i> и как <i>AUTH $User</i>. Однако, имена переменных регистрозависимы, подробнее <a href="#vars">про переменные</a> ниже.

<b>Важное замечание.</b> Формат YAML позволяет не заключать строки в кавычки. Но для интерпретатора строка без кавычек - выражение, которое надо вычислить. Например объявление поля <code>url: http://example.com/login</code> приведет к синтаксической ошибке при выполнении. Поэтому правильно будет: <code>url: "http://example.com/login"</code> или <code>url: "http://"+$domain+"/login"</code>

<h4>Описание метода API состоит из следующих полей</h4>
<i><b>method</b></i> - HTTP-метод, обязательное

<i><b>url</b></i> - собственно URL,  обязательное

<i><b>headers</b></i> - список HTTP-заголовков,  необязательное

<i><b>cookies</b></i> - список cookie,  необязательное

<i><b>auth</b></i> - данные для HTTP-аутентификации, необязательное
<source lang="code">auth:
  login: $login
  password: $password
  type: "basic" // или "digest" или "ntlm", по-умолчанию "basic"</source>
<i><b>query</b></i> - список параметров URL, необязательное

<i><b>format</b></i> - одно из значений: <i>none</i> - у запроса нет тела, <i>json</i> - отправка в JSON, <i>raw</i> - отправка строки "как есть", <i>form</i> -  в формате application/x-www-form-urlencoded, <i>multipart</i> - в формате multipart/form-data. Необязательное, по-умолчанию <i>none</i>

<i><b>data</b></i> - тело запроса, будет отправлено в формате заданном в <i>format</i>,  необязательное
Для формата <i>none</i> - <i>data</i> может отсутствовать, если присутствует, будет проигнорировано
Для формата <i>json</i> - любое значение
Для формата <i>raw</i> - любое скалярное значение
Для формата <i>form</i> - массив, ключи которого - названия полей,
<source lang="code">data:
  login: $login
  password: $password
  remember_me: 1</source>
Для формата <i>multipart</i> - массив, ключи которого - названия полей, следующей структуры:
<source lang="code">data:
    user_id:
        value: 42
        headers:
            X-Baz: "bar"
    avatar:
        file: "/path/to/file"
    photo:
        file: "http://url.to/file"
        filename: "custom_filename.jpg"</source>
Файлы, указанные в полях <i>file</i>, должны быть доступны для чтения. Если указан URL, то в php.ini должна быть включена опция <a href="http://php.net/manual/en/filesystem.configuration.php#ini.allow-url-fopen">allow_url_fopen</a>

<i><b>before</b></i> - операторы, которые будут выполнены до HTTP-запроса, необязательное

<i><b>after</b></i> - операторы, которые будут выполнены после HTTP-запроса, необязательное

Идея блоков <i>before</i> и <i>after</i> в выполнении проверок или обработке каких-либо данных, которые нужны каждый раз до или после выполнения HTTP-запроса, и продиктованы не столько нуждами тестирования, сколько бизнес-логикой. Например, копирование выданного токена авторизации в поле структуры $user для вызова всех последующих методов API от имени этого пользователя. Или для проверки HTTP-статуса ответа, чтоб не проверять его каждый раз после вызова в сценарии.

<anchor>call</anchor><h2>Вызов метода API</h2>
Вызывается метод API очень просто - достаточно в сценарии указать его имя и, если надо, параметры. Вот пример вызова последнего метода API из описания выше:
<source lang="code">Create comment $comments.1 on {$newPost} by {$postAuthor}</source>
Если параметр заключен в фигурные скобки, он будет передан по значению - так может быть передано любое выражение. Если указать параметр без фигурных скобок, он будет передан по ссылке - это могут быть только переменные и статические обращения к элементам массива (через точку, но не через скобки []).
<source lang="code">Create comment {$comments[$i]} on $posts.0 by $users.1
Read post {123} by $user
Get comments of $users.1.id {{$page = 2}}</source>
При каждом вызове метода API в контексте самого вызова (в списках операторов <i>before</i> и <i>after</i>) и в контексте, где, он был вызван, создаются переменные <i>$request</i> и <i>$response</i>. Это зарезервированные имена, не рекомендую использовать их для других целей. <i>$request</i> доступна в обоих блоках <i>before</i> и <i>after</i>, а <i>$response</i> только в <i>after</i>, в <i>before</i> ее значение становится <i>Null</i>. В вызывающем контексте эти переменные доступны до следующего вызова метода API, где они будут заново пориницилизированы.

<h4>Структура $request</h4>
<b>$request.method</b> - String - HTTP-метод
<b>$request.url</b> - String - запрашиваемый URL
<b>$request.query</b> - Array - список GET-параметров
<b>$request.headers</b> - Array - список заголовков запроса
<b>$request.cookies</b> - Array - список cookies
<b>$reuqest.auth</b> - Array или Null - данные для HTTP-аутентификации
<b>$request.format</b> - String - формат данных запроса
<b>$request.data</b> - тип любой - то что было вычислено в поле <i>data</i>

<h4>Структура $response</i></h4>
<b>$response.network</b> - Boolean - false, если ошибка была на сетевом уровне ниже HTTP
<b>$response.code</b> - Number или Null - код ответа, например, 200 или 404
<b>$response.status</b> - String или Null - статус ответа, например, "204 No Content" или "401 Unauthorized"
<b>$response.headers</b> - Array - список заголовков ответа, имена заголовков приведены к нижнему регистру
<b>$response.cookies</b> - Array - список cookies
<b>$response.body</b> - тип любой  - тело ответа обработанное как JSON, если была ошибка при парсинге, то элемента <i>body</i> вообще не будет: <code>@response.body == null</code> (<a href="#var_exists">о проверке существования переменных</a>)
<b>$response.raw</b> - String или Null - необработанное тело ответа
<b>$response.duration</b> - тип Number - длительность запроса в секундах

<anchor>generators</anchor><h2>Генерация моделей и тестовых данных</h2>
Генераторы служат для описания моделей и генерации по ним тестовых данных. Они описываются в формате YAML в файле <i>generators.yaml</i> в рабочей директории и/или из всех файлов <i>*.yaml</i> в поддиректории <i>./generators</i>.

<source lang="code">User:
    body:
        login: Faker\login()
        name: Faker\name()
        email: Faker\email()
        password: Faker\text(16)
        child: Child()
        birthday: dateFormat(Faker\datetime(), "U")
        settings:
            notifications_enabled: Faker\boolean()

Child:
    body:
        name: Faker\name()
        gender: Faker\integer(1, 2)
        age: Faker\integer(0, 18)

Comment($user):
    body:
        content: "Hi! I'm " + $user.name
        tags:
            - "tag1"
            - "tag2"
</source>
В примере выше объявлено три генератора <i>User()</i>, <i>Child()</i> и <i>Comment()</i>. При этом последний имеет аргумент <i>$user</i> и может использовать эти данные при генерации. Аргументы в генераторы всегда передаются по значению. Кроме того, в примере используются еще несколько встроенных функций: <i>Faker\name()</i>, <i>Faker\email()</i>, <i>dateFormat()</i>, и т.д. О встроенных функциях <a href="#functions">расскажу ниже</a>.

При вызове генератора <i>User()</i> из примера выше будет сгенерирована структура, которая в JSON выглядит примерно так:
<source lang="json">{
  "login": "fgadrkq",
  "name": "Lucy Cechtelar",
  "email": "tkshlerin@collins.com",
  "password": "gbnaueyaaf",
  "child": {
    "name": "Adaline Reichel",
    "gender": 2,
    "age": 12
  },
  "birthday": 318038400,
  "settings": {
    "notifications_enabled": true
  }
}
</source>
Для поля <i>child:</i> его значением будет результат работы генератора <i>Сhild()</i>.
Как и в описании методов API, любые строки, не заключенные в кавычки, рассматриваются как выражения, которые будут вычислены. Это может быть не только вызов другого генератора, а произвольное выражение, например, в генераторе <i>Comment($user)</i> поле <i>content</i> представляет конкатенацию строки "Hi! I'm " и имени переданного <i>$user</i>

Имена генераторов регистронезависимы и должны начинаться с латинской буквы, могут содержать в себе латинские буквы, цифры, подчеркивание и обратный слеш.
Поскольку синтаксис вызова генераторов и встроенных функций одинаков, они делят общее пространство имен. Обратный слеш я предлагаю по соглашению использовать в качестве разделителя для указания "вендора" или библиотеки встроенных функций, как например функции Faker\something(), основанные на библиотеке https://github.com/fzaninotto/Faker.

<spoiler title="Нюансы использования генераторов, можно не читать">
При помощи генераторов можно компановать  структуры:
<source lang="code">
# UserСredentials основана на данных из $user
UserСredentials($user):
    body:
        login: $user.email
        password: $user.password

# Примерная структура ответа соц. сети на поиск по постам, комментам и пользователям
GlobalSearchResult($posts, $comments, $users):
    body:
        posts:
            title: "Найденные посты"
            list: $posts
        comments:
            title: "Найденные комментарии"
            list: $comments
        users:
            title: "Найденные пользователи"
            list: $users
</source>
<i>GlobalSearchResult</i> представляет собой не тестовые данные, которые посылаются в запросе к методу API, а модель ответа, которую можно сверить с тем, что пришлет API, например, использованием функций <a href="#functions"><i>similar()</i></a> или <a href="#functions"><i>identical()</i></a>.

Генератор может изменять структуру получаемую в <i>body</i> с помощью структур вычисляемых в полях <i>replace</i> и <i>remove</i>. Лучше покажу на примере.

Допустим, уже есть генератор <i>User()</i>, который создает правильную структуру данных для пользователя. Теперь надо проверить как API будет реагировать, если представить неправильные данные. Можно пойти двумя путями:
- Создать генератор "неправильного" пользователя с нуля. Но тогда, при добавлении пользователю нового поля по нуждам бизнес-логики, придется вносить правки уже в два места. DRY!
- Можно "отнаследоваться" от уже имеющейся структуры User(), задав его в <i>body</i>. А в <i>replace</i> и <i>remove</i> задать, поля которые будут добавлены/изменены и удалены.
<source lang="code">
# Вернет структуру как у переданного пользователя, но изменит два поля,
# сделав его невалидным для проверки этапа регистрации
InvalidUser($user):
    body: $user
    replace:
        email: Faker\String(6, 15) # Неавлидный емейл
        password: Faker\String(1, 5) # Слишком короткий пароль
        new_field: "этого поля у правильного пользователя не было, теперь будет"

# А так можно сгенерировать случайного пользователя,
# а потом изменить или удалить пару  полей
InvalidNewUser:
    body: User()
    replace:
        login: "!@#$%^&*" # Невалидный логин
    remove:
        about: true
        settings:
            notifications: 100500 # Неважно какое именно значение будет у поля,
                                  # главное чтоб оно было объявлено
</source>

При использовании полей <i>replace</i> и <i>remove</i> сначала вычисляется структура в <i>body</i>, а потом перезаписывается и дополняется элементами из <i>replace</i> и потом удаляются поля указанные в <i>remove</i>. Если результат вычисления <i>body</i>, <i>replace</i> или <i>remove</i> не массивы, то ошибки не будет, но и смысла в этом никакого нет, т.к не будет полей которые можно было бы заменить и удалить.
</spoiler>

<anchor>functions</anchor><h2>Встроенные функции</h2>
<a href="https://github.com/maximw/PieceofScript/blob/master/docs/internal_functions.md">Полный список встроенных функций</a>. Для примера приведу только некоторые из них.
После имени функции и списка аргументов указан <a href="#types">тип</a> возвращаемого значения, если он определен.

<h4>Операции с переменными:</h4>
<b>similar</b>($var, $sample) <i>Boolean</i> - возвращает <i>true</i>, если аргументы имеют одинаковый тип, если <i>$var</i> - массив, то все строковые ключи, которые есть в <i>$sample</i>, должны быть в <i>$var</i>, при этом типы соответсвующих элементов должны совпадать. Другими словами, элементы массива <i>$var</i> являются подмножеством элементов <i>$sample</i>.
<b>identical</b>($var, $sample) <i>Boolean</i> - аналог <i>similar()</i>, с дополнительным обрантым условием, в случае массивов, все строковые ключи в <i>$var</i> должны быть и в <i>$sample</i>. Другими словами элементы массива <i>$var</i> равны элементам массива <i>$sample</i> с точностью до типа элемента.
<b>max</b>($var1, $var2, ... $varN)  - максимальное из переданных значений (если они поддаются сравнению).
<b>min</b>($var1, $var2, ... $varN)  - минимальное из переданных значений.
<b>if</b>($condition, $var1, $var2)  - Если $condition == true, то вернет $var1, иначе $var2. Замена тренарному оператору (привет MySQL).
<b>choice</b>($condition1, $var1, $condition2, $var2, ..., $conditionN, $varN)  - Вернет первое встреченное $varK, если $conditionK == true.

<h4>Работа со строками:</h4>
<b>size</b>($string) <i>Number</i> - длина строки в кодировке UTF-8.
<b>regex</b>($string, $regex) <i>Boolean</i> - проверка строки на <a href="http://php.net/manual/en/pcre.pattern.php">регулярное выражение</a>.
<b>regexMatch</b>($string, $regex) <i>Array</i> - вернет массив строк - совпадений с группами регулярки <i>$regex</i>.

<h4>Обработка массивов:</h4>
<b>array</b>($var1, $var2, ... $varN) <i>Array</i> - создаст массив из переданных элементов.
<b>size</b>($array) <i>Number</i> - количество элементов массива.
<b>keys</b>($array) <i>Array</i> - список ключей массива.
<b>slice</b>($array, $offset, $length) <i>Array</i> - часть массива от $offset длиной $length, (<a href="http://php.net/manual/en/function.array-slice.php">подробнее</a>).
<b>append</b>($array, $value) <i>Array</i> - добавить элемент в конец массива.
<b>prepend</b>($array, $value) <i>Array</i> - добавить элемент в начало массива.

<h4>Обработка дат:</h4>
<b>dateFormat</b>($date, $format) <i>String</i> - форматирование даты, (<a href="http://php.net/manual/en/datetime.formats.php">подробнее про форматы</a>).
<b>dateModify</b>($date, $format) <i>Date</i> - изменение даты, удобно использовать с <a href="http://php.net/manual/en/datetime.formats.relative.php">Relative Formats</a>.

<h4>Генерация случайных тестовых данных:</h4>
<b>Faker\integer</b>($min, $max) <i>Number</i> - случайное целое от $min до $max включительно
<b>Faker\ipv4</b>() <i>String</i> - случайный IPv4
<b>Faker\arrayElement</b>($array) <i>String</i> - случайный элемент из массива
<b>Faker\name</b>() <i>String</i> - случаное имя
<b>Faker\email</b>() <i>String</i> - случайный email

Сейчас встроенных функций не очень много. Я добавил только то, что мне кажется будет необходимым при тестировании. Добавлять новые функции можно по мере необходимости в новых версиях. А будущем, если будет востребовано, добавлю возможность создавать динамически-подключаемые функции, реализованные в виде специальных классов на PHP.

<anchor>testcases</anchor><h2>Тест-кейсы</h2>
Тест-кейс это последовательность операторов, которая может быть вызвана как единое целое.
Тест-кейс создается оператором <i>testcase</i>, за которым следует имя тест-кейса, с синтаскисом и требованиями как у имен <a href="#methods">методов API</a>. Вложенные тест-кейсы запрещены.

<source lang="code">testcase Registration $device
   //Тест на регистрацию валидного пользователя
   var $user = User()
   Register $user on $device
   assert $response.code == 201

   //Тест на регистрацию пользователя с неправильной электронной почтой
   var $user = User() // хотя можно было бы сделать генератор InvalidUser()
   var $user.email = "some_bad_email"
   Register $user on $device
   assert $response.code == 400
</source>

Оператор <i>run</i> может вызвать отдельный тест-кейс, либо все тест-кейсы, которые не требуют аргументов.
<source lang="code">
run Get all users     // Запуск отдельного тест-кейса, не требующего аргументов
run Get user $user_id // Запуск отдельного тест-кейса с аргументом
run                   // Запуск всех тесткейсов, которые не требуют аргументов
</source>
Идея такого запуска в том, что тест-кейсы можно использовать как отдельные независимые тесты части бизнес-логики и роли функций, для избежания дублирования кода в сложных сценариях тестирования.

Аргументы в тест-кейс передаются по ссылке или по значению в полной аналогии передачи аргументов в методы API.

<anchor>vars</anchor><h2>Переменные и области видимости</h2>
Имена переменных регистрозависимы и начинаются со знака <i>$</i> (да-да, я пхпшник).

Если переменная типа <i>Array</i>, то доступ к отдельным полям или элементам значения производится через точку: <code>$users.12.password</code>. Между точками допускаются либо только цифры, либо латинские буквы, подчеркивания и цифры с первой латинской буквой. Имена полей тоже регистрозависимы.
Возможно динамическое обращение к элементу массива: <code>$post.comments[$i + 1].content</code>

<anchor>contexts</anchor>Есть четыре типа контекстов - областей видимости переменных.

<b>Глобальный контекст</b> - создается на старте, содержит все переменные объявленные при выполнении операторов вне тест-кейсов и вне вызовов методов API.

<b>Контекст тест-кейса</b> - создается новый при каждом выполнении тест-кейса оператором <i>run</i>.

<b>Контекст метода API</b> - создается при вызове метода API, при выполнении операторов, указанных в секциях <i>before</i> и <i>after</i>.

<b>Контекст генератора</b> - в генераторах нет возможности создания новых или изменения существующих переменных, поэтому доступны только для чтения переменные глобального контекста и аргументы. Переменные в контекст генератора передаются всегда по значению.

<b>Важное замечание.</b> Внутри всех контекстов доступны переменные глобального контекста, если в текущем контексте не созданы их "тезки".

Примеры операторов работы с переменными:
<source lang="code">const $a = 1
let $a = 2 // Будет выдано предупреждение
var $b = 1
const $b = 3 // Будет выдана ошибка
const $c = 3; $c = 4 // Будет выдана ошибка, $c уже определно в первой секции
</source>
<source lang="code">let $a = 1; $a = $a + 1; $a = $a + 2
print $a // 4
</source>
<source lang="code">Testcase Context example changes $argument1, $argument2 and $argument3
   var $a = "changed"
   let $b = "changed"
   const $c = "changed"
   import $i
   let $i = "changed"
   var $argument1 = "changed"
   var $argument2 = "changed"
   var $argument3 = "changed" // предупреждение, по ссылке передали константу

var $a = "original"
var $b = "original"
var $i = "original"
const $c = "original";
var $paramByRef = "original"
var $paramByVal = "original"
const $paramConst = "original"

run Context example changes $paramByRef, {$paramByVal} and $paramConst

// новая $a была создана в контексте тест-кейса
print $a // "original"

//  $b не было в контексте тест-кейса, и let обратился к глобальной $b
print $b // "changed"

// $i была импортирована из глобального контекста
print $i // "original"

// константы создаются в каждом контексте свои, аналогично var создает переменные
print $c // "original"

// параметр передавался по ссылке
print $paramByRef // "changed"

// параметр передавался по значению
print $paramByVal // "original"

// константа была передана по ссылке, но измениться не может
print $paramConst // "original"
</source>

<anchor>types</anchor><h2>Система типов и операции</h2>
Используется нестрогая динамическая типизация.
Значения хранятся в "обертках" над соответсвтующими типами PHP.  Для лучшего понимания можно <a href="http://php.net/manual/en/language.types.php">ознакомиться</a> системой типов PHP. Я сделал немного меньше свободы в динамическом преобразовании типов. Например, при сложеннии строки и числа <code>"2" + 2</code>, будет выдана ошибка, а PHP спокойно выполнит сложение. Возможно мне нужно будет пересмотреть правила динамической типизации в будущем, но пока, я попытался найти баланс между удобством и строгостью, необходимой для надежных тестов.

Типы данных, доступные в PieceofScript:

<b><a href="https://github.com/maximw/PieceofScript/blob/master/docs/type_number.md">Number</a></b> - число. Из соображений простоты я не стал делать отдельные типы для Integer и Float. Единственное существенное отличие целых и вещественных чисел в PieceofScript - использование в качестве ключей массива: вещественные числа будут округлены до целых.
<code>7 -42 3.14159</code>

<b><a href="https://github.com/maximw/PieceofScript/blob/master/docs/type_string.md">String</a></b> - строки, заключенные в двойные кавычки, возможно экранирование слешем
<code>"I say \"Hello world!\""</code>

<b><a href="https://github.com/maximw/PieceofScript/blob/master/docs/type_null.md">Null</a></b> - задается регистронезависимой константой
<code>null</code>

<b><a href="https://github.com/maximw/PieceofScript/blob/master/docs/type_boolean.md">Boolean</a></b> - является результатом булевых операций и операций сравнения, задается регистронезависимыми константами
<code>true false</code>

<b><a href="https://github.com/maximw/PieceofScript/blob/master/docs/type_date.md">Date</a></b> - дата и время. "Под капотом" это <a href="http://php.net/manual/en/class.datetime.php">DateTime</a>. Константы задаются в одинарных кавычках, в одном из <a href="http://php.net/manual/en/datetime.formats.php">форматов</a>.
<code>'now', '2008-08-07 18:11:31', 'last day of next month'</code>

<b><a href="https://github.com/maximw/PieceofScript/blob/master/docs/type_array.md">Array</a></b> - массив, единственный не скалярный тип. Обертка над <a href="http://php.net/manual/en/language.types.array.php">Array</a>. Литералов этого типа нет, но массивы могут быть результатом работы генераторов, встроенных функций (например, <i>array()</i> - привет PHP 5.3 и ниже), или можно просто обращаться к ключам переменных, которые будут динамически создаваться при присвоении.
<source>let $a.1 = 100
let $i = 1
let $a[$i + 1] = 200
let $a.sum = $a.1 + $a.2
print "Сумма "; $a.sum // Сумма 300
var $b = array(true, 3, $a, "Hi") // [true, 3, {1: 100, 2: 200, "sum":300}, "Hi"]
</source>
При обращении к несуществующей переменной или элементу массива, сценарий тестирования будет остановлен и выдана ошибка. Но при выполнении операторов <i>assert</i> или <i>must</i>, если происходит обращение к несуществующей переменной, ошибки не будет, но проверка будет считаться проваленой.

<anchor>var_exists</anchor><h4>Проверка существования и типа переменной</h4>
Отдельно надо упомянуть констукцию проверки существования и типа переменной <b><i>@</i></b>.
Если в имени переменной вместо <i>$</i> указать <i>@</i>, то результатом работы этой конструкции будет одно из:
- строка с именем типа переменной или типа элемента массива, если использовались ключи;
- <i>null</i>, если переменная не найдена в доступных контекстах или элемента с указанным ключем в массиве не существует.
Эта конструкция может быть удобна при проверках структуры HTTP-ответов.
<source>var $a.string_field = "Hello World"
var $a.number_field = 3.14
var $a.bool_field = true
var $a.date_field = '+1 day'
var $a.null_field = null
var $a.array_field = array(1, "2")

assert @a.string_field == "String"
assert @a.number_field == "Number"
assert @a.bool_field == "Boolean"
assert @a.date_field == "Date"
assert @a.null_field == "Null"
assert @a.array_field  == "Array"
assert @a.array_field.0  == "Number"
assert @a.array_field.1  == "String"
assert @a.array_field.2  == null
assert @notExistedVar == null
</source>
Или в конструкциях типа:
<source lang="code">assert @comment.optional_field && $comment.optional_field > 20</source>
Булевые операции оптимизированы по первому операнду. Если первый операнд равен <i>false</i>, то операция <i>&&</i> даже не будет пытаться вычислить второй операнд. Аналогично с <i>||</i>.

<anchor>storage</anchor><h2>Сохранение данных между запусками</h2>
Я использовал отдельные сценарии не только для тестирования после завершения задачи, но и в ходе разработки, когда раз за разом надо выполнять одни и те же действия. Я дополнял и изменял сценарий по мере того как реализовывал фичу. Потом этот сценарий становился основой для написания тесткейса. При этом каждый раз в сценарии создавать новые сущности с нуля (например, регистрация пользователя) было долго, создавало мусор в базе данных и всячески мешало от разработке. Поэтому я решил добавить возможность сохранять и восстанавливать значения переменных между запусками в key-value хранилище.

Сохранение включается опцией командной строки <i>--storage</i>, задающей имя файла-хранилища:
<source lang="bash">pos.phar run ./start.pos --storage=storage.yaml</source>Данные сохраняются в формате yaml, что позволяет их легко читать и редактировать.

<b>storage\get</b>(string $key, $defaultValue, boolean $saveValue=true) - если ключ $key не существует или файл-хранилище не задан, возвращает $defaultValue. Иначе возвращает сохраненное значение. Если аргумент $saveValue равен true, а ключ $key не найден, туда будет записано $defaultValue.

<b>storage\set</b>(string $key, $value) - сохраняет $value с ключем $key, и возвращает $value. Если файл-хранилище не был задан, то просто возвращает $value.

<b>storage\key</b>(string $regexp=null) <i>Array</i> - возвращает массив всех имеющихся ключей. Если аргумент $regexp не null, то вернутся ключи соответсвтующие этому регулярному выражению. Если файл-хранилище не был задан, то возвращает пустой массив.

<anchor>output</anchor><h2>Вывод в stdout</h2>
Различная информация работы интерпретатора выводится в stdout. После завершения отчет может быть сформирован в формате JUnit, если при запуске в командной строке была указана опция <code>--junit</code>

Есть 5 стандартных уровней вывода информации. Все что выводится на одном уровне, выводится и на остальных более "болтливых".

<b>Quiet</b> - самый "молчаливый" уровень задается опцией командной строки <b>-q</b>.
На этом уровне ничего не выводится в stdout, даже критические ошибки интерпретатора. Но по ненулевому коду возврата, можно понять, что что-то пошло не так.

<b>Normal</b> - это уровень по-умолчанию, без задания опций.
На этом уровне выводятся ошибки в работе интепретатора. Ошибочные запросы к методам API и провалившиеся проверки <i>assert</i> и <i>must</i>.

<b>Verbose</b> - задается опцией <b>-v</b>.
На этом уровне выводятся результаты работы оператора <i>print</i>.

<b>Very verbose</b> - задается опцией <b>-vv</b>.
На этом уровне выводятся предупреждения интерпретатора.

<b>Debug</b> - задается опцией <b>-vvv</b>.
На этом уровне выводятся все выполняемые строки сценария. Все запросы и ответы методов API, результаты работы всех проверок <i>assert</i> и <i>must</i>.

<anchor>examples</anchor><h2>Примеры</h2>
Пословица "Лучше один раз увидеть, чем сто раз услышать" справедлива и в интерпретации "лучше один раз увидеть код, чем сто раз прочитать его описание". Примеры подготовил и положил в репозиторий <a href="https://github.com/maximw/PosExamples">https://github.com/maximw/PosExamples</a>.

<h3>Pastery</h3>
Аналог Pasebin. <a href="https://www.pastery.net/api/">Документация к API</a>.
Для досутпа к API нужно зарегистрироваться, получить ключ, и добавить его в файл
Pastery/globals.pos.
Запуск тестов: <source lang="bash">pos.phar run ./Pastery/start.pos  -vvv</source>

<h3>The Rick and Morty</h3>
Думаю, этот мультсериал известен многим, и многоими любим. <a href="https://rickandmortyapi.com/documentation/#rest">Документация к API</a>.
Запуск тестов: <source lang="bash">pos.phar run ./RickAndMorty/20MinutesTest.pos  -vvv</source>

Если вы знаете публичный API, который вам было бы интересно потестировать таким образом, напишите, пожалуйста, в личку.

<anchor>plans</anchor><h2>Замечания и планы на будущее, если оно будет</h2>
<b>1)</b> Для валидации моделей в ответах API с использованием генераторов есть пока только две функции - <i>similar()</i> и <i>identical()</i>. Валидация с ними слишком "топорная". Конечно уже сейчас можно валидировать ответы "руками", и в некоторых случаях иначе никак, но хочу сделать это более удобным и, где можно, избежать ручной проверки ответа. Есть некоторые идеи, как сделать возможность и генерировать, и валидировать модели используя одино и то же описание модели, избегая дублирования. Но пока эти идеи не сформировались достаточно, чтоб можно было реализовать их в коде.

<b>2)</b> Думаю, очень полезным будет возможность скаффолдинга для методов API на основе описания в OpenAPI (<a href="https://swagger.io/">Swagger</a>), <a href="https://raml.org">RAML</a>, коллекций <a href="https://www.getpostman.com">Postman</a>. Но это большая работа, за которую стоит сесть, если PieceofScript того стоит. Скаффолдинг первоочередная задача, не считая правки багов.

<b>3)</b> Хорошо было бы сделать плагин(ы) для некоторых IDE, с подсветкой кода и автодополнением. Автодополнение имен тест-кейсов, методов API, операторов и переменных было бы просто архиудобно. Но еще не "копал" в этом направлении. Разбираюсь с созданием подсветки для Sublime Text.

<b>4)</b> Не знаю в какой приоритет поставить возможность создания динамически подключаемых <a href="#functions">функций</a>, реализованных на PHP. С одной стороны там все просто, достаточно разобраться с автозагрузкой и сделать спецификацию используемых классов и неймспейсов. С другой стороны сложные функции со своими зависимостями неминуемо вызовут конфилкт неймспейсов у зависимостей (в худшем случае еще и разных версий). Тут тоже есть над чем думать.

<b>5)</b> Хорошие системы тестирования запускают независимые тесты параллельно. Сейчас это можно сделать, запустив интерпреататор несколько раз с разными стартовыми файлами, где подключаются разные тест-кейсы. Но я думаю, надо встроить это в сам интерпретатор с автоматическим определением того, что может быть запущего параллельно.

P.S. С одной стороны, поскольку это моя "поделка", логично было бы засунуть пост в хаб "Я пиарюсь". С другой стороны, я не пиаюсь, просто инструмент который, делал для себя, решил "причесать" и выложить публично. В любом случае по ограничениям Хабра не могу писать в хаб "Я пиарюсь".