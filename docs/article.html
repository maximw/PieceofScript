Хочу рассказать про PieceofScript - простой язык для написания сценариев автоматического тестирования HTTP JSON API. 

Что может PieceofScript:<ul>
	<li>описывать методы API в формате yaml, с названием метода на почти естественном языке, что удобно для чтения тестов</li>
	<li>достаточно гибко описывать модели в формате yaml и генерировать по ним рандомные данные</li>
	<li>писать сложные сценарии вызовов API языком с несложным синтаксисом, с упором на легкость чтения</li>
	<li>получать результаты тестирования в формате JUnit</li>
</ul>
По сути очередной "велосипед", но кроме автоматического тестирования, для меня PieceofScript оказался удобен и в процессе разработки. Мне проще накидать небольшой сценарий и дополнять его по мере реализации задачи, сразу тестируя сделанное, чем каждый раз выполнять все запросы вручную.

Мотивация для написания была банальна: меня вгонял в уныние интерфейс SoapUI. Хотелось просто и понятно описывать тесты в текстовом редакторе без специального GUI. Кроме того, огромный xml-файл, который выдает SoapUI, довольно плохо "переваривается" git'ом, и тесты на конкретную задачу сложно положить в той же ветке, где сделана сама задача. Я немного изучил другие инструменты тестирования, у каждого был "<a href="http://lurkmore.to/%D0%A4%D0%B0%D1%82%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BE%D0%BA">фатальный недостаток</a>", поэтому я в припадке <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D0%B4%D1%80%D0%BE%D0%BC_%D0%BD%D0%B5%D0%BF%D1%80%D0%B8%D1%8F%D1%82%D0%B8%D1%8F_%D1%87%D1%83%D0%B6%D0%BE%D0%B9_%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8">NIH-синдрома</a> открыл IDE.

Расскажу подробнее что из этого вышло, поехали.

<img src="https://habrastorage.org/webt/be/su/_o/besu_olm_gbromxnr34mzcvy8sy.gif" />
<cut />

Интерпретатор написан на PHP и представляет собой phar-архив, требует версию PHP 7.1 или выше. Свежий 7.3, конечно, приятнее, но хотелось большей совместимости, и при этом не опускаться до "пятерки". Исходный код и документация доступны тут https://github.com/maximw/PieceofScript. Документация в разработке. Это, как оказалось, самая трудная и нудная часть. 

<a href="#struct">Проект тестирования, его cтруктура и запуск</a>
<a href="#script">Сценарий тестирования</a>
<a href="#methods">Методы тестируемого API</a>
<a href="#call">Вызов метода API</a>
<a href="#generators">Генерация моделей и тестовых данных</a>
<a href="#functions">Встроенные функции</a>
<a href="#testcases">Тест-кейсы</a>
<a href="#vars">Переменные и области видимости</a>
<a href="#types">Типы и операции</a>
<a href="#output">Вывод в stdout</a>
<a href="#examples">Примеры</a> - хватит слов, покажи код!
<a href="#plans">Замечания и планы на будущее, если оно будет</a>

<anchor>struct</anchor><h2>Проект тестирования, его cтруктура и запуск</h2>
Проект представляет собой директорию с набором файлов-сценариев, файлов описания методов API и генераторов тестовых данных. 
В минимальной версии проект выглядит так:
<source>./tests
  endpoints.yaml        - Методы API
  generators.yaml       - Генераторы
  start.pos             - Стартовый сценарий тестирования</source>
Стартовый файл - это сценарий с которого начинается процесс тестирования. Он задается при запуске:
<source lang="bash">pos.phar run ./start.pos --junit-report=result_in_junit_format.xml -vvv --config=config.yaml</source>
Все относительные пути считаются от рабочей директории, содержащей стартовый файл. 
Конфигурационный файл можно задать в командной строке опцией <i>--config</i> или положить <i>config.yaml</i> в рабочую директорию. Конфиг не обязателен, туда нужно лезть по необходимости. <a href="https://github.com/maximw/PieceofScript/blob/master/docs/configuration.md">Подробнее про конфиг</a>. 


<anchor>script</anchor><h2>Сценарий тестирования</h2>
Для себя решил писать сценарии в файлах с расширением .pos, чтоб можно было сделать настройки подсветки кода в IDE с привязкой по расширению. Но интерпретатору совершенно безразлично расширение.

Вот простой пример для воображаемой соц. сети, где выполняется тест создания и прочтения поста разными пользователями. 
<source lang="code">require "./globals.pos" // Здесь определим глобальные переменные, например $domain 
include "./globals_local.pos" // Здесь можно переопределить глобальные переменные, для другого окружения 
include "./user/*.pos" // Подключаем все что найдем в ./user
include "./post/*.pos"

// Это вызовы генераторов. Сгенерируем несколько моделей пользователей и поста
var $author = User()
var $reader = User()
var $banned = User() 
var $post = Post()

Register $author // Вызов метода API, который регистрирует переданного пользователя	
Register $reader 
Register $banned 
Add $banned to blacklist of $author //$banned больше не может видеть посты $author

Create post $post by $author // Вызов метода API создания поста
must $response.code == 201 // Проверка что метод API ответил кодом 201
assert $response.body.post.content == $post.content // ...и, на всякий случай, что пост создался
var $postId = $response.body.post.id // Id созданного поста еще пригодится

Read post $postId by $author // Прочитать пост самим автором
must $response.code == 200
assert $response.body.post.content == $post.content

Read post $postId by $reader // И прочитать пост другим пользователем
must $response.code == 200
assert $response.body.post.content == $post.content

Read post $postId by $banned // А для этого пост будет не найден
assert $response.code == 404
</source>
Да, без подсветки выглядит не очень.

Каждая выполнимая строка сценария либо начинается с оператора, либо является вызовом метода API. Если вдруг имя метода API начинается со слова совпадающего с одним из операторов, можно использовать символ "<i>></i>":
<source>>Include $user to group $userGroup</source>
Операторы регистронезависимы. assert, ASSERT или aSsErT (но зачем так писать?) будут работать.
Каждый оператор или вызов метода API должны находиться на отдельной строке. Но возможен и перенос строк, если последний символ строки <i>\</i> (привет, Python). 
<spoiler title="Неинтересные подробности про переносы строк">
Если перенос строки  использовать в комментарии, то следующая строка будет тоже считаться частью комментария. При переносе строк внутри блоков (<i>testcase</i>, <i>if</i>, <i>while</i>, <i>foreach</i>) важно соблюдать отступы, чтоб следующая строка попала в тот же блок.
<source lang="code">var $n = 20
var $i = 2
var $fib1 = 1; \
    $fib2 = 1
while $i <= $n
    var $fib_sum = \
        $fib2 + $fib1
    print toString($i) + " число Фиббоначи:" + \
        toString($fib_sum)
    var $fib1 = $fib2
    var $fib2 = $fib_sum
    var $i = $i + 1</source>

При выполнении блочных операторов (<i>testcase</i>, <i>if</i>, <i>while</i>, <i>foreach</i>) блок определяется отступами его строк. Отступ считается как количество пробельных символов в начале строки. И пробел, и табуляция считаются за один символ, но табуляция обычно отображается в редакторах как несколько пробелов. Поэтому для избежания неразберихи лучше использовать или табы, или пробелы, но не все вместе.
</spoiler>

<h4>Полный список операторов:</h4>
<b>require <i>fileName</i></b> - подключить файл в место вызова оператора. Тут же начнет выполняться подключенный файл с первой его строки. По завершению выполнения, интерпретатор вернется к следующей строке исходного файла. Если запрашиваемый файл не доступен для чтения, то будет выдана ошибка. Относительный путь считается от рабочей директории.

<b>include <i>fileMask</i></b> - аналогично require, но если запрашиваемый файл не доступен для чтения, то ошибки не будет. Это удобно, например, для создания настроек для разных окружений тестирования. Кроме того, include умеет подключать сразу все файлы по маске. Так, например, можно загрузить целые директории файлов, содержащих только тесткейсы. Но никакая очередность загрузки файлов не гарантируется.

<b>var <i>$variable1 = expression1</i>; <i>$variable2 = expression2</i>; ... ; <i>$variableN = expressionN</i></b> - присвоить значения переменным. Если переменной нет, она будет создана в текущем контексте.

<b>let <i>$variable1 = expression1</i>; <i>$variable2 = expression2</i>; ... ; <i>$variableN = expressionN</i></b> - присвоить значения переменным. Если переменной нет в текущем контексте, будет попытка создать или изменить переменную в глобальном контексте.

<b>const <i>$const1 = expression1</i>; <i>$const2 = expression2</i>; ... ; <i>$constN = expressionN</i></b> - установить значение констант в текущем контексте. Отличие констант от переменных только в том, что их нельзя изменять, при попытке присвоить значение константе после объявления будет выдано предупрежение. Eсли переменная с таким именем уже есть в текущем контексте, то будет выдана ошибка. В остальном все что справедливо для переменных, справедливо и для констант.

<b>import <i>$variable1</i>; <i>$variable2</i>; ... ;<i>$variableN</i></b> - копирует переменные из глобального в текущий контекст. Может пригодиться, если надо оперировать со значением глобальной переменной, но не изменить его.

<b>testcase <i>testCaseName</i></b> - создать тест-кейс, который потом можно вызвать как единое целое оператором <i>run</i>. Подробнее про <a href="#testcases">тест-кейсы</a> далее.

<b>assert <i>expression</i></b> - проверить что выражение <i>expression</i> равно <i>true</i>, в противном случае вывести отчет о провалившемся тесте.

<b>must <i>expression</i></b> - то же самое, что и <i>assert</i>, только в случае провала теста, выполнение текущего тест-кейса будет прекращено, а вне контекста тест-кейса будет вообще прекращено дальнейшее выполнение сценария. Может использоваться, если поймана ошибка, с которой дальнейшие проверки не имеют смысла.

<b>run <i>testCaseName</i></b> - запустить на выполнение заданный тест-кейс. <i>run </i> без указания имени тест-кейса запустит все доступные тест-кейсы, не требующие аргументов, в порядке их объявления.

<b>while <i>expression</i></b> - цикл, пока <i>expression</i> истинно, выполняет операторы с отступом строки больше чем у <i>while</i>.

<b>foreach <i>$array</i>; <i>$element</i></b> - цикл прохода по массиву, тело цикла выполняется для каждого очередного элемента массива. Возможно получение еще и ключа <b>foreach <i>$array</i>; <i>$key</i>; <i>$element</i></b>. Переменные <i>$key</i> и <i>$element</i> создаются/перезаписываются в текущем контексте.

<b>if <i>expression</i></b> - если <i>expression</i> истинно, выполняет операторы с отступом строки больше чем у <i>if</i>

<b>print <i>expression1</i>; <i>expression2</i>; ... <i>expressionN</i></b> - вывести значение выражениях <i>expressionM</i> в stdout. Может использоваться для отладки, работает только с уровнем "болтливости" <i>--verbosity=1</i> или <i>-v</i> и больше.

<b>sleep <i>expression</i></b> - сделать паузу на заданное число, необязательно целое, секунд. Иногда надо дать тестируемому API передышку.

<b>pause <i>expression</i></b> - не в интерактивном режиме (опция командной строки <i>-n</i>) аналогичен <i>sleep</i>. <i>Expression</i> не обязательно, в этом случае паузы не будет. А в интерактивном режиме сделать паузу до нажатия Enter. 

<b>cancel</b> - закончить тестирование. Интерпретатор заканчивает работу, создает отчеты и т.д. Полагаю, может использоваться для отладки при запуске части сценария "вручную".

<anchor>methods</anchor><h2>Методы тестируемого API</h2>
Это собственно то, что надо тестировать - вызывать с определенными параметрами и проверять соответствует ли ответ ожиданиям.
Методы API описываются в формате YAML. Описания должны находиться в файле <i>endpoints.yaml</i> текущей директории и/или в файлах <i>*.yaml</i> в ее поддиректории <i>./endpoints</i>. Перед тестированием интерпретатор попытается вычитать сразу все эти файлы.

Пример структуры <i>endpoints.yaml</i>:
<source lang="yaml">Auth $user:
    method: "POST"
    url: $domain + "/login"
    headers:
        Content-Type: "application/json"
    auth:
        login: "user"
        password: "qwerty"
        type: "basic"
    format: "json"
    data:
        login: $user.login
        password: $user.password
    after:
        - assert $response.code == 200
        - let $user.auth_token = $response.body.auth_token

Create post $post by $user:
    method: "POST"
    url: $domain + "/posts"
    format: "json"
    data: $post 
    headers:
        auth: "Bearer " + $user.auth_token
        content-type: "application/json"
    after:     
        - assert $response.code == 201	

Read post $postId by $user:
    method: "GET"
    url: $domain + "/posts/" + $postId
    headers:
        auth: "Bearer " + $user.auth_token
        content-type: "application/json"
    after:
        - assert ($response.code == 200) || ($response.code == 404)

Create comment $comment on $post by $user:
    method: "POST"
    url: $domain + "/comments/create/" + $post.id
    format: "json"
    data: $comment
    headers: 
        auth: "Bearer " + $user.auth_token
        content-type: "application/json"
    after:     
        - assert $response.code == 201	
</source>
На верхнем уровне структуры yaml задается имя, по которому потом метод API будет доступен для вызова. Оно представляет собой строку в почти произвольном формате.

В любом месте имени могут быть указаны аргументы, которые будут приняты при вызове метода. Они должны быть отделены пробелами от остальных слов в имени. Например <i>$comment</i>, <i>$post</i> и <i>$user</i> в последнем методе. Если в качестве аргумента принята переменная, даже если это элемент массива, значение будет передано по ссылке из контекста, где метод API был вызван. Остальные, используемые переменные, например <i>$domain</i> в примере выше, будут взяты из глобального контекста. Подробнее <a href="#contexts">про контексты</a> расскажу дальше. 

Мне кажется, удобно давать методам API человеко-понятные имена на естественном языке, тогда сценарий тестирования легче читать. Имена регистронезависимы, т.е метод <i>Auth $User</i> может быть вызван как <i>auth $User</i> и как <i>AUTH $User</i>. Однако, имена аргументов регистрозависимы, подробнее <a href="#vars">про переменные</a> ниже.

<b>Важное замечание.</b> Формат YAML позволяет не заключать строки в кавычки. Но для интерпретатора строка без кавычек - выражение, которое надо вычислить. Например объявление поля <code>url: http://example.com/login</code> приведет к синтаксической ошибке при выполнении. Поэтому правильно будет: <code>url: "http://example.com/login"</code> или <code>url: "http://"+$domain+"/login"</code>

<h4>Описание метода API состоит из следующих полей</h4>
<i><b>method</b></i> - HTTP-метод, обязательное

<i><b>url</b></i> - собственно URL,  обязательное

<i><b>headers</b></i> - список HTTP-заголовков,  необязательное

<i><b>cookies</b></i> - список cookie,  необязательное

<i><b>auth</b></i> - данные для HTTP-аутентификации, необязательное
<source lang="code">auth:
  login: $login
  password: $password
  type: "basic" // или "digest" или "ntlm", по-умолчанию "basic"</source>
<i><b>query</b></i> - список параметров URL, необязательное

<i><b>format</b></i> - одно из значений <i>none</i> - у запроса нет тела, <i>json</i> - отправка в JSON, <i>raw</i> - отправка строки "как есть", <i>form</i> -  в формате application/x-www-form-urlencoded, <i>multipart</i> - в формате multipart/form-data. Необязательное, по-умолчанию <i>none</i>

<i><b>data</b></i> - тело запроса, будет отправлено в формате заданном в <i>format</i>,  необязательное
Для формата <i>none</i> - <i>data</i> может отсутствовать, если присутствует, будет проигнорировано
Для формата <i>json</i> - любое значение
Для формата <i>raw</i> - любое скалярное значение
Для формата <i>form</i> - массив, ключи которого - названия полей, 
<source lang="code">data:
  login: $login
  password: $password
  remember_me: 1</source>
Для формата <i>multipart</i> - массив, ключи которого - названия полей, следующей структуры:
<source lang="code">data:
    user_id:
        value: 42
        headers:
            X-Baz: "bar"
    avatar:
        file: "/path/to/file"
    photo:
        file: "http://url.to/file"
        filename: "custom_filename.jpg"</source>
Файлы, указанные в полях <i>file</i>, должны быть доступны для чтения. Если указан URL, то в php.ini должна быть включена опция <a href="http://php.net/manual/en/filesystem.configuration.php#ini.allow-url-fopen">allow_url_fopen</a>

<i><b>before</b></i> - список операторов интерпретатора, которые будут выполнены до HTTP-запроса, необязательное 

<i><b>after</b></i> - список операторов интерпретатора, которые будут выполнены после HTTP-запроса, необязательное

Идея списков <i>before</i> и <i>after</i> в выполнении проверок или обработке каких-либо данных, которые нужны каждый раз до или после выполнения HTTP-запроса, и продиктованы не столько нуждами тестирования, сколько бизнес-логикой. Например, копирование выданного токена авторизации в поле структуры $user для вызова всех последующих методов API от имени этого пользователя. Или для проверки HTTP-статуса ответа.

<anchor>call</anchor><h2>Вызов метода API</h2>
Вызывается метод API очень просто, достаточно в сценарии указать его имя и, если надо, параметры. Вот пример вызова последнего метода API из описания выше:
<source lang="code">Create comment $comments.1 on $newPost by $postAuthor</source>
В общем случае при вызове метода API параметры должны быть заключены в фигурные скобки. Исключение - переменные и статические обращения к элементам массива (через точку) - их не обязательно заключать в фигурные скобки.
<source lang="code">Create comment {$comments[$i]} on $posts.0 by $users.1
Read post {123} by $user:
Get page {$lastPage + 1} of comments by $users.1.id</source>
При каждом вызове метода API в контексте самого вызова (в списках операторов <i>before</i> и <i>after</i>) и в контексте, где, он был вызван, создаются переменные <i>$request</i> и <i>$response</i>. Это зарезервированные имена, не рекомендую использовать их для других целей. <i>$request</i> доступна в обоих блоках <i>before</i> и <i>after</i>, а <i>$response</i> только в <i>after</i>, в <i>before</i> ее значение становится <i>Null</i>. В вызывающем контексте эти переменные доступны до следующего вызова метода API, где они будут заново пориницилизированы.

<h4>Структура $request</h4>
<b>$request.method</b> - String - HTTP-метод
<b>$request.url</b> - String - запрашиваемый URL
<b>$request.query</b> - Array - список GET-параметров
<b>$request.headers</b> - Array - список заголовков запроса
<b>$request.cookies</b> - Array - список cookies
<b>$reuqest.auth</b> - Array или Null - данные для HTTP-аутентификации
<b>$request.format</b> - String - формат данных запроса
<b>$request.data</b> - тип любой - то что было вычислено в поле <i>data</i>


<h4>Структура $response</i></h4>
<b>$response.network</b> - Boolean - false, если ошибка была на сетевом уровне ниже HTTP
<b>$response.code</b> - Number или Null - код ответа, например, 200 или 404
<b>$response.status</b> - String или Null - статус ответа, например, "204 No Content" или "401 Unauthorized"
<b>$response.headers</b> - Array - список заголовков ответа, имена заголовков приведены к нижнему регистру 
<b>$response.cookies</b> - Array - список cookies
<b>$response.body</b> - тип любой  - тело ответа обработанное как JSON, если была ошибка при парсинге, то элемента <i>body</i> вообще не будет: <code>@response.body == null</code> (<a href="#var_exists">о проверке существования переменных</a>)
<b>$response.raw</b> - String или Null - необработанное тело ответа
<b>$response.duration</b> - тип Number - длительность запроса в секундах

При обращении к несуществующей переменной или элементу массива всегда будет остановлен сценарий тестирования и выдана ошибка. Однако, при выполнении операторов <i>assert</i> или <i>must</i>, если происходит обращение к несуществующей переменной, ошибки не будет, но проверка будет считаться проваленой.

<anchor>generators</anchor><h2>Генерация моделей и тестовых данных</h2>
Генераторы служат для описания моделей и генерации по ним тестовых данных. Они описываются в формате YAML в файле <i>generators.yaml</i> в рабочей директории и/или из всех файлов <i>*.yaml</i> в поддиректории <i>./generators</i>. 

<source lang="code">User:
    body:
        login: Faker\login()
        name: Faker\name()
        email: Faker\email()
        password: Faker\text(16)
        child: child()
        tags:
            - tag1
            - tag2
        birthday: dateFormat(Faker\datetime(), "U")
        settings:
            notifications_enabled: Faker\boolean()

Child:
    body:
        name: Faker\name()
        gender: Faker\integer(1, 2)
        age: Faker\integer(0, 18)

Comment($user):
    body:
        content: "Hi! I'm " + $user.name
</source>
В примере выше объявлено три генератора <i>User()</i>, <i>Child()</i> и <i>Comment()</i>. При этом последний имеет аргумент <i>$user</i> и может использовать эти данные при генерации. Аргументы в генераторы всегда передаются по значению. Кроме того, в примере используются еще несколько встроенных функций: <i>Faker\name()</i>, <i>Faker\email()</i>, <i>dateFormat()</i>, и т.д. О встроенных функциях <a href="#functions">расскажу ниже</a>.

При вызове генератора <i>User()</i> из примера выше будет сгенерирована структура, которая в JSON выглядит примерно так: 
<source lang="json">{
  "login": "fgadrkq",
  "name": "Lucy Cechtelar",
  "email": "tkshlerin@collins.com",
  "password": "gbnaueyaaf",
  "child": {
    "name": "Adaline Reichel",
    "gender": 2,
    "age": 12
  },
  "tags": [
    "tag1",
    "tag2"
  ],
  "birthday": 318038400,
  "settings": {
    "notifications_enabled": true
  }
}
</source>
Для поля <i>child:</i> его значением будет результат работы генератора <i>Сhild()</i>.
Как и в описании методов API, любые строки, не заключенные в кавычки, рассматриваются как выражения, которые будут вычислены. Это может быть не только вызов другого генератора, а произвольное выражение, например, в генераторе <i>Comment($user)</i> поле <i>content</i> представляет конкатенацию строки "Hi! I'm " и имени переданного <i>$user</i>

Имена генераторов регистронезависимы и должны начинаться с латинской буквы, могут содержать в себе латинские буквы, цифры, подчеркивание и обратный слеш. 
Поскольку синтаксис вызова генераторов и встроенных функций одинаков, они делят общее пространство имен. Обратный слеш я предлагаю по соглашению использовать в качестве разделителя для указания "вендора" или библиотеки встроенных функций, как например функции Faker\something(), основанные на библиотеке https://github.com/fzaninotto/Faker. 

<spoiler title="Нюансы использования генераторов, можно не читать">
При помощи генераторов можно компановать  структуры:
<source lang="code">
# UserСredentials основана на данных из $user
UserСredentials($user): 
    body:
        login: $user.email
        password: $user.password

# Примерная структура ответа соц. сети на поиск по постам, комментам и пользователям
GlobalSearchResult($posts, $comments, $users):
    body:
        posts: 
            title: "Найденные посты"
            list: $posts
        comments: 
            title: "Найденные комментарии"
            list: $comments
        users: 
            title: "Найденные пользователи"
            list: $users
</source>
<i>GlobalSearchResult</i> представляет собой не тестовые данные, которые посылаются в запросе к методу API, а модель ответа, которую можно сверить с тем, что пришлет API, например, использованием функций <a href="#functions"><i>similar()</i></a> или <a href="#functions"><i>identical()</i></a>.

Генератор может изменять структуру получаемую в <i>body</i> с помощью структур вычисляемых в полях <i>replace</i> и <i>remove</i>. Лучше покажу на примере.

Допустим, уже есть генератор <i>User()</i>, который создает правильную структуру данных для пользователя. Теперь надо проверить как API будет реагировать, если представить неправильные данные. Можно пойти двумя путями:
- Создать генератор "неправильного" пользователя с нуля. Но тогда, при добавлении пользователю нового поля по нуждам бизнес-логики, придется вносить правки уже в два места. DRY!
- Можно "отнаследоваться" от уже имеющейся структуры User(), задав его в <i>body</i>. А в <i>replace</i> и <i>remove</i> задать, поля которые будут добавлены/изменены и удалены.
<source lang="code">
# Вернет структуру как у переданного пользователя, но изменит два поля, 
# сделав его невалидным для проверки этапа регистрации
InvalidUser($user):
    body: $user 
    replace:
        email: Faker\String(6, 15) # Неавлидный емейл
        password: Faker\String(1, 5) # Слишком короткий пароль
        new_field: "этого поля у правильного пользователя не было, теперь будет"

# А так можно сгенерировать случайного пользователя,
# а потом изменить или удалить пару  полей
InvalidNewUser:
    body: User() 
    replace:
        login: "!@#$%^&*" # Невалидный логин
    remove:
        about: true
        settings:
            notifications: 100500 # Неважно какое именно значение будет у поля,
                                  # главное чтоб оно было объявлено      
</source>

При использовании полей <i>replace</i> и <i>remove</i> сначала вычисляется структура в <i>body</i>, а потом перезаписывается и дополняется элементами из <i>replace</i> и потом удаляются поля указанные в <i>remove</i>. Если результат вычисления <i>body</i>, <i>replace</i> или <i>remove</i> не массивы, то ошибки не будет, но и смысла в этом никакого нет, т.к не будет полей которые можно было бы заменить и удалить.
</spoiler>

<anchor>functions</anchor><h2>Встроенные функции</h2>
Встроенные функции предназначены в первую очередь для генерации тестовых данных, как и генераторы, и для небольших манипуляций с данными. 

Вот тут <a href="https://github.com/maximw/PieceofScript/blob/master/docs/internal_functions.md">полный список встроенных функций</a>. Для примера приведу только некоторые из них. 
После имени функции и списка аргументов указан <a href="#types">тип</a> возвращаемого значения, если он определен.

<h4>Операции с переменными:</h4>
<b>similar</b>($var, $sample) <i>Boolean</i> - возвращает <i>true</i>, если аргументы имеют одинаковый тип, если <i>$var</i> - массив, то все строковые ключи, которые есть в <i>$sample</i>, должны быть в <i>$var</i>, при этом типы соответсвующих элементов должны совпадать. Другими словами, элементы массива <i>$var</i> являются подмножеством элементов <i>$sample</i>.
<b>identical</b>($var, $sample) <i>Boolean</i> - аналог <i>similar()</i>, с дополнительным обрантым условием, в случае массивов, все строковые ключи в <i>$var</i> должны быть и в <i>$sample</i>. Другими словами элементы массива <i>$var</i> равны элементам массива <i>$sample</i> с точностью до типа элемента.
<b>max</b>($var1, $var2, ... $varN)  - максимальное из переданных значений (если они поддаются сравнению).
<b>min</b>($var1, $var2, ... $varN)  - минимальное из переданных значений.
<b>if</b>($condition, $var1, $var2)  - Если $condition == true, то вернет $var1, иначе $var2. Замена тренарному оператору.
<b>choice</b>($condition1, $var1, $condition2, $var2, ..., $conditionN, $varN)  - Вернет первое встреченное $varK, если $conditionK == true.

<h4>Работа со строками:</h4>
<b>size</b>($string) <i>Number</i> - длина строки в кодировке UTF-8.
<b>regex</b>($string, $regex) <i>Boolean</i> - проверка строки на <a href="http://php.net/manual/en/pcre.pattern.php">регулярное выражение</a>.
<b>regexMatch</b>($string, $regex) <i>Array</i> - вернет массив строк - совпадений с группами регулярки <i>$regex</i>.

<h4>Обработка массивов:</h4>
<b>array</b>($var1, $var2, ... $varN) <i>Array</i> - создаст массив из переданных элементов.
<b>size</b>($array) <i>Number</i> - количество элементов массива.
<b>keys</b>($array) <i>Array</i> - список ключей массива.
<b>slice</b>($array, $offset, $length) <i>Array</i> - часть массива от $offset длиной $length, (<a href="http://php.net/manual/en/function.array-slice.php">подробнее</a>).
<b>append</b>($array, $value) <i>Array</i> - добавить элемент в конец массива.
<b>prepend</b>($array, $value) <i>Array</i> - добавить элемент в начало массива.

<h4>Обработка дат:</h4>
<b>dateFormat</b>($date, $format) <i>String</i> - форматирование даты, (<a href="http://php.net/manual/en/datetime.formats.php">подробнее про форматы</a>).
<b>dateModify</b>($date, $format) <i>Date</i> - изменение даты, удобно использовать с <a href="http://php.net/manual/en/datetime.formats.relative.php">Relative Formats</a>.

<h4>Генерация случайных тестовых данных:</h4>
<b>Random\Date</b>($min, $max, $withTime) <i>Date</i> - случайная дата от $min до $max включительно, если $withTime = true, то будет и случайное время, иначе полночь.
<b>Random\Choice</b>($value1, $weight1, $value2, $weight2,...  $valueN, $weightN) - можно передать любое четное количество аргументов, вернет $valueN c вероятностью  $weightN / "сумма всех весов"
<b>Faker\Integer</b>($min, $max) <i>Number</i> - случайное целое от $min до $max включительно
<b>Faker\Char</b>($min, $max) <i>String</i> - случайный символ от $min до $max включительно
<b>Faker\String</b>($min, $max) <i>String</i> - случайную строку из символов a-z дилной от $min до $max включительно
<b>Faker\Name</b>() <i>String</i> - случаное имя
<b>Faker\Email</b>() <i>String</i> - случайный email

Сейчас этот список довольно скуден. Я добавил только то, что мне кажется будет необходимым при тестировании, не хочу слишком перегружать язык. Добавлять новые функции можно по мере необходимости в новых версиях. А будущем, если будет востребовано, добавлю возможность создавать динамически-подключаемые функции, реализованные в виде специальных классов на PHP.

<anchor>testcases</anchor><h2>Тест-кейсы</h2>
Тест-кейс это последовательность операторов, которая может быть вызвана как единое целое.
Создание тест-кейса начинается с оператора <i>testcase</i> за которым следует имя тест-кейса, с требованиями как у имен <a href="#methods">методов API</a>.

<source lang="code">testcase Registration $device
   //Тест на регистрацию валидного пользователя
   var $user = User()
   Register $user on $device
   assert $response.code == 201

   //Тест на регистрацию пользователя с неправильной электронной почтой
   var $user = User() // хотя можно было бы сделать генератор InvalidUser()
   var $user.email = "some_bad_email"
   Register $user on $device
   assert $response.code == 400
</source>
Все операторы, у которых отступ начала строки больше чем у строки с оператором <i>testcase</i>, считаются принадлежащими тесткейсу. Они будут выполнены не сразу, а после запуска тест-кейса оператором <i>run</i>. В контексте тест-кейса нельзя использовать <i>testcase</i>, т.е. вложенные тест-кейсы запрещены.

<i>run</i> может вызвать отдельный тест-кейс, либо все тест-кейсы, которые не требуют аргументов. 
<source lang="code">
run Get all users     // Запуск отдельного тест-кейса, не требующего аргументов 
run Get user $user_id // Запуск отдельного тест-кейса с аргументом
run                   // Запуск всех тесткейсов, которые не требуют аргументов
</source>
Идея в том, что тест-кейсы можно использовать как отдельные независимые наборы проверок части бизнес-логики, либо как часть для более сложного сценария, где может потребоваться передача данных из вызывающего контекста. 

В пером случае достаточно подключить все файлы содержащие тесткейсы, и запустить их одним оператором <i>run</i>. 
Во втором каждый тест-кейс должен вызываться отдельно. И поскольку тест-кейс предполагается частью сценария, аргументы передаются по ссылке, т.е. значения переменных могут быть изменены и в вызывающем контексте. Разумеется, можно смешивать оба этих подхода.

<anchor>vars</anchor><h2>Переменные и области видимости</h2>
Имена переменных регистрозависимы и начинаются со знака <i>$</i> (да-да, я пхпшник), далее должна следовать латинская буква, далее латинские буквы, подчеркивание <i>_</i> или цифры. 

Если значение переменной типа <i>Array</i>, то доступ к отдельным полям или элементам значения производится через точку: <code>$users.12.password</code>. Между точками допускаются либо только цифры, либо латинские буквы, подчеркивания и цифры с первой латинской буквой. Имена полей тоже регистрозависимы.
Возможно динамическое обращение к элементу массива: <code>$post.comments[$i + 1].content</code>

<anchor>contexts</anchor>Есть четыре типа контекстов - областей видимости переменных.

<b>Глобальный контекст</b> - создается на старте, содержит все переменные объявленные при выполнении операторов вне тест-кейсов.

<b>Контекст тест-кейса</b> - создается новый при каждом выполнении тест-кейса оператором <i>run</i>. Переменные в контекст тест-кейса передаются по ссылке. 

<b>Контекст метода API</b> - создается при вызове метода API, при выполнении операторов, указанных в секциях <i>before</i> и <i>after</i>. Переменные в контекст метода API передаются по ссылке.

<b>Контекст генератора</b> - в генераторах нет возможности создания новых или изменения существующих переменных, поэтому доступны только для чтения переменные глобального контекста и аргументы. Переменные в контекст генератора передаются по значению.

<b>Важное замечание.</b> Внутри всех контекстов доступны переменные глобального контекста, если в текущем контексте не объявлены их "тезки" операторами <i>var</i>, <i>const</i>, <i>import</i> или в качестве аргументов.

Примеры операторов работы с переменными:
<source lang="code">const $a = 1
let $a = 2 // Будет выдано предупреждение
var $b = 1
const $b = 3 // Будет выдана ошибка
const $c = 3; $c = 4 // Будет выдана ошибка, $c уже определно в первой секции 
</source>
<source lang="code">let $a = 1; $a = $a + 1; $a = $a + 2
print $a // 4
</source>
<source lang="code">Testcase Context example changes $argument1 and $argument2
   var $a = "changed"
   let $b = "changed"
   const $c = "changed"
   import $i
   let $i = "changed"
   var $argument1 = "changed"
   var $argument2 = "changed" // предупреждение, по ссылке передали константу

var $a = "original"
var $b = "original"
var $i = "original"
const $c = "original"; 
var $param = "original"
const $constParam = "original"

run Context example changes $param and $constParam

// новая $a была создана в контексте тест-кейса
print $a // "original"

//  $b не было в контексте тест-кейса, и let обратился к глобальной $b
print $b // "changed"

// $i была импортирована из глобального контекста 
print $i // "original"

// константы создаются в каждом контексте свои, аналогично var создает переменные
print $c // "original"

// параметры передаются по ссылке
print $param // "changed"
</source>

<anchor>types</anchor><h2>Система типов и операции</h2>
Используется нестрогая динамическая типизация. 
Значения хранятся в "обертках" над соответсвтующими типами PHP.  Для лучшего понимания можно <a href="http://php.net/manual/en/language.types.php">ознакомиться</a> системой типов PHP. Я сделал немного меньше свободы в динамическом преобразовании типов. Например, при сложеннии строки и числа <code>"2" + 2</code>, будет выдана ошибка, а PHP спокойно выполнит сложение. Возможно мне нужно будет пересмотреть правила динамической типизации в будущем, но пока, я попытался найти баланс между удобством и строгостью, необходимой для надежных тестов.

Типы данных, доступные в PieceofScript:

<b><a href="https://github.com/maximw/PieceofScript/blob/master/docs/type_number.md">Number</a></b> - число. Из соображений простоты я не стал делать отдельные типы для Integer и Float. Единственное существенное отличие целых и вещественных чисел в PieceofScript - использование в качестве ключей массива: вещественные числа будут округлены до целых.
<code>7 -42 3.14159</code>

<b><a href="https://github.com/maximw/PieceofScript/blob/master/docs/type_string.md">String</a></b> - строки, заключенные в двойные кавычки, возможно экранирование слешем 
<code>"I say \"Hello world!\""</code>

<b><a href="https://github.com/maximw/PieceofScript/blob/master/docs/type_null.md">Null</a></b> - задается регистронезависимой константой 
<code>null</code>

<b><a href="https://github.com/maximw/PieceofScript/blob/master/docs/type_boolean.md">Boolean</a></b> - является результатом булевых операций и операций сравнения, задается регистронезависимыми константами
<code>true false</code>

<b><a href="https://github.com/maximw/PieceofScript/blob/master/docs/type_date.md">Date</a></b> - дата и время. "Под капотом" это <a href="http://php.net/manual/en/class.datetime.php">DateTime</a>. Константы задаются в одинарных кавычках, в одном из <a href="http://php.net/manual/en/datetime.formats.php">форматов</a>.
<code>'now', '2008-08-07 18:11:31', 'last day of next month'</code>

<b><a href="https://github.com/maximw/PieceofScript/blob/master/docs/type_array.md">Array</a></b> - массив, единственный не скалярный тип. Обертка над <a href="http://php.net/manual/en/language.types.array.php">Array</a>. Литералов этого типа нет, но массивы могут быть результатом работы генераторов, встроенных функций (например, <i>array()</i> - привет PHP 5.3 и ниже), или можно просто обращаться к ключам переменных, которые будут динамически создаваться при присвоении.
<code>let $a.1 = 100
let $i = 1
let $a[$i + 1] = 200
let $a.sum = $a.1 + $a.2
print "Сумма "; $a.sum // Сумма 300
var $b = array(true, 3, $a, "Hi") // [true, 3, {1: 100, 2: 200, "sum":300}, "Hi"]
</code>

<anchor>var_exists</anchor><h4>Проверка существования и типа переменной</h4>
Отдельно надо упомянуть констукцию проверки существования и типа переменной <b><i>@</i></b>.   
Если в имени переменной вместо <i>$</i> указать <i>@</i>, то результатом работы этой конструкции будет одно из:
- строка с именем типа переменной или типа элемента массива, если использовались ключи; 
- <i>null</i>, если переменная не найдена в доступных контекстах или элемента с указанным ключем в массиве не существует.
Эта конструкция может быть удобна при проверках структуры HTTP-ответов. Например при таком ответе:
<source lang="json">{
  "string_field": "Hello World", // @response.body.string_field == "String"
  "number_field": 3.14,          // @response.body.number_field == "Number"
  "bool_field": true,            // @response.body.bool_field == "Boolean"
  "array_field": [               // @response.body.array_field == "Array"
    1,
    2,
    3                            // @response.body.array_field.2 == "Number"
                                 // @response.body.array_field.3 == null
  ],
  "null_field": null             // @response.body.null_field == "Null"
                                 // @response.body.any_other_field == null
}</source>
Или в конструкциях типа:
<source lang="code">assert @comment.optional_field && $comment.optional_field > 20</source>
Булевые операции оптимизированы по первому операнду. Если первый операнд равен <i>false</i>, то операция <i>&&</i> даже не будет пытаться вычислить второй операнд. Аналогично с <i>||</i>. 

<anchor>output</anchor><h2>Вывод в stdout</h2>
Различная информация работы интерпретатора выводится в stdout. После завершения отчет может быть сформирован в формате JUnit, если при запуске в командной строке была указана опция <code>--junit-report</code>

Есть 5 стандартных уровней вывода информации. Все что выводится на одном уровне, выводится и на остальных более "болтливых".

<b>Quiet</b> - самый "молчаливый" уровень задается опцией командной строки <b>-q</b>.
На этом уровне ничего не выводится в stdout, даже критические ошибки интерпретатора. Но по ненулевому коду возврата, можно понять, что что-то пошло не так.
 
<b>Normal</b> - это уровень по-умолчанию, без задания опций.
На этом уровне выводятся ошибки в работе интепретатора. Ошибочные запросы к методам API и провалившиеся проверки <i>assert</i> и <i>must</i>.

<b>Verbose</b> - задается опцией <b>-v</b>.
На этом уровне выводятся результаты работы оператора <i>print</i>.

<b>Very verbose</b> - задается опцией <b>-vv</b>.
На этом уровне выводятся предупреждения интерпретатора. 

<b>Debug</b> - задается опцией <b>-vvv</b>.
На этом уровне выводятся все выполняемые строки сценария. Все запросы и ответы методов API, результаты работы всех проверок <i>assert</i> и <i>must</i>.

<anchor>examples</anchor><h2>Примеры</h2>
Пословица "Лучше один раз увидеть, чем сто раз услышать" справедлива и в интерпретации "лучше один раз увидеть код, чем сто раз прочитать его описание". Для примеров подготовил сценарии тестирования некоторых публичных API.

<h3>The Rick and Morty API (or ShlaAPI)</h3>
Думаю, этот мультсериал известен многим.  Документация к API <a href="https://rickandmortyapi.com/documentation">тут</a>. 



<anchor>plans</anchor><h2>Замечания и планы на будущее, если оно будет</h2>
<b>1)</b> Сейчас не очень хорошо реализован парсинг вызовов методов API и запуска тест-кейсов. Там или нужен полноценный лексер, или придется отказаться от свободного формата именования в ущерб читабельности. Возможны проблемы с парсингом передаваемых параметров, поэтому не стоит в вызове передавать уж слишком сложные выражения. Кроме того, нельзя передавать литералы, ну это очевидно, т.к. в обоих случаях, и методов API, и тест-кейсов, передача идет по ссылке.

<b>2)</b> Для валидации моделей в ответах API с использованием генераторов есть пока только две функции - <i>similar()</i> и <i>identical()</i>. Валидация с ними слишком "топорная". Конечно уже сейчас можно валидировать ответы "руками", и в некоторых случаях иначе никак, но хочу сделать это более удобным и, где можно, избежать полного "ручного" разбора ответа. Есть некоторые идеи, как сделать возможность и генерировать, и валидировать модели используя одино и то же описание модели, избегая дублирования. Но пока эти идеи не сформировались достаточно, чтоб можно было реализовать их в коде.

<b>3)</b> Думаю, очень полезным будет возможность скаффолдинга для методов API на основе описания в OpenAPI (<a href="https://swagger.io/">Swagger</a>), <a href="https://raml.org">RAML</a>, коллекций <a href="https://www.getpostman.com">Postman</a>. Но это большая работа, за которую стоит сесть, если PieceofScript того стоит. Буду проверять на своей "шкуре", поэтому скаффолдинг первоочередная задача.

<b>4)</b> Хорошо было бы сделать плагин(ы) для некоторых IDE, с подсветкой кода и автодополнением. Автодополнение имен тест-кейсов, методов API, операторов и переменных было бы просто архиудобно. Но еще "копал" в этом направлении. Разбираюсь с созданием подсветки для Sublime Text.

<b>5)</b> Не знаю в какой приоритет поставить возможность создания динамически подключаемых <a href="#functions">функций</a>, реализованных на PHP. С одной стороны там все просто, достаточно разобраться с автозагрузкой и сделать спецификацию используемых классов и неймспейсов. С другой стороны сложные функции со своими зависимостями неминуемо вызовут конфилкт неймспейсов у зависимостей (в худшем случае еще и разных версий). Тут тоже есть над чем думать.

<b>6)</b> Хорошие системы тестирования запускают независимые тесты параллельно. Сейчас это можно сделать, запустив интерпреататор несколько раз с разными стартовыми файлами, где подключаются разные тест-кейсы. Но я думаю, надо встроить это в сам интерпретатор с автоматическим определением того, что может быть запущего параллельно.

P.S. С одной стороны, поскольку это моя "поделка", логично было бы засунуть пост в хаб "Я пиарюсь". С другой стороны, я не пиаюсь, просто инструмент который, делал для себя, решил "причесать" и выложить публично. В любом случае по ограничениям Хабра не могу писать в хаб "Я пиарюсь".