Хочу рассказать про PieceofScript - простой язык для написания сценариев автоматического тестирования HTTP JSON API.

По сути очередной "велосипед", который на текущий момент имеет скорее академический, чем практический интерес, и то только для меня. Решил вот, так сказать, вынести этот сор из избы.

Мотивация для написания была банальна: меня вгонял в уныние интерфейс SoapUI. Хотелось просто и понятно описывать тесты в текстовом редакторе без специального GUI. Кроме того, огромный xml-файл, который выдает SoapUI, довольно плохо "переваривается" git'ом, и тесты на конкретную задачу сложно положить в той же ветке, где сделана сама задача. Я немного изучил другие инструменты тестирования, у каждого был "<a href="http://lurkmore.to/%D0%A4%D0%B0%D1%82%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BE%D0%BA">фатальный недостаток</a>", поэтому я в припадке <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D0%B4%D1%80%D0%BE%D0%BC_%D0%BD%D0%B5%D0%BF%D1%80%D0%B8%D1%8F%D1%82%D0%B8%D1%8F_%D1%87%D1%83%D0%B6%D0%BE%D0%B9_%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8">NIH-синдрома</a> открыл IDE.

Расскажу подробнее что из этого вышло, поехали.

<img src="https://habrastorage.org/webt/be/su/_o/besu_olm_gbromxnr34mzcvy8sy.gif" />
<cut />

Интерпретатор написан на PHP и представляет из себя phar-архив, требует версию PHP 7.0 или выше. Свежий 7.3, конечно, приятнее, но хотелось большей совместимости, и при этом не опускаться до "пятерки". Исходный код доступен тут https://github.com/maximw/PieceofScript. Документацию пишу тут https://github.com/maximw/PieceofScript/wiki. Документация, как ремонт, его нельзя закончить, можно только прекратить. Так что прошу прощения за возможные неточности и пробелы.

<a href="#struct">Проект тестирования, его cтруктура и запуск</a>
<a href="#script">Сценарий тестирования</a>
<a href="#methods">Методы тестируемого API</a>
<a href="#call">Вызов метода API</a>
<a href="#generators">Генерация моделей и тестовых данных</a>
<a href="#functions">Встроенные функции</a>
<a href="#testcases">Тест-кейсы</a>
<a href="#vars">Переменные и области видимости</a>
<a href="#types">Типы и операции</a>
<a href="#output">Вывод в stdout</a>
<a href="#todo">Пример тестирования приложения TODO-лист</a> - хватит слов, покажи код!
<a href="#plans">Замечания и планы на будущее, если оно будет</a>

<anchor>struct</anchor><h2>Проект тестирования, его cтруктура и запуск</h2>
Проект представляет из себя директорию с набором файлов-сценариев, файлов описания методов API и генераторов тестовых данных.
В минимальной версии проект выглядит так:
<source>./tests
  endpoints.yaml        - Методы API
  generators.yaml       - Генераторы
  start.pos             - Стартовый сценарий тестирования</source>
Если что-то посложнее проект может примерно так:
<source>./tests
  /post                 - Тут тест-кейсы для постов
  /comments_testcases   - Тут тест-кейсы для комментариев
  /user                 - Тест-кейсы пользователей разбиты на директории
    /login
    /registration
  /generators           - Описания генераторов тоже разложены по директориям
    /post
        post_generators.yaml
    users.yaml
  /endpoints
    all_endpoints.yaml  - А описания методов API собраны в один файл
  config.yaml           - Файл настроек инетрпретатора, его может и не быть
  endpoints.yaml        - Методы API, этого файла тоже может и не быть
  global_config.pos     - Сценарий-конфиг, можно задать какие-то глобальные значения
  global_config_dev.pos - и переопределить их для другого окружения
  generators.yaml       - Генераторы, и этого файла тоже может и не быть
  start.pos             - Стартовый сценарий тестирования
  some_other.pos        - А можно начинать тестирование и с этого, там другой сценарий</source>
Стартовый файл - это сценарий с которого начинается процесс тестирования. Он задается при запуске:
<source lang="bash">pos.phar run ./start.pos --junit=result_in_junit_format.xml -vvv --config=config.yaml</source>
Конфигурационный файл можно задать в командной строке опцией <i>--config</i> или положить <i>config.yaml</i> в текущую директорию. Конфиг не обязателен, туда нужно лезть по необходимости. <a href="https://github.com/maximw/PieceofScript/wiki/Configuration">Подробнее про конфиг</a>.

<anchor>script</anchor><h2>Сценарий тестирования</h2>
Сценарий тестирования это последовательность команд - в основном вызовы методов API и проверки результатов. Я решил писать сценарии в файлах с расширением .pos, чтоб можно было сделать настройки подсветки кода в IDE с привязкой по расширению. Но интерпретатору совершенно безразлично расширение, можно использовать любое или не использовать вообще.

Вот простой пример, где выполняется тест создания и прочтения поста разными пользователями.
<source lang="code">require ./globals.pos // Здесь определим глобальные переменные, например $domain
include ./globals_dev.pos // Здесь можно переопределить глобальные переменные
include ./user/*.pos // Подключаем все что найдем в ./user
include ./post/*.pos

// Это вызовы генераторов. Сгенерируем несколько моделей пользователей и поста
var $author = User()
var $reader = User()
var $banned = User()
var $post = Post()

Register $author // Вызов метода API, который регистрирует переданного пользователя
Register $reader
Register $banned
Add $banned to blacklist of $author //$banned больше не может видеть посты $author

Create post $post by $author // Вызов метода API создания поста
must $response.code == 201 // Проверка что метод API ответил кодом 201
assert $response.body.post.content == $post.content // ...и, на всякий случай, что пост создался
var $postId = $response.body.post.id // Id созданного поста еще пригодится

Read post $postId by $author // Прочитать пост самим автором
must $response.code == 200
assert $response.body.post.content == $post.content

Read post $postId by $reader // И прочитать пост другим пользователем
must $response.code == 200
assert $response.body.post.content == $post.content

Read post $postId by $banned // А для этого пост будет не найден
assert $response.code == 404
</source>

Каждая выполнимая строка сценария либо начинается с команды, либо является вызовом метода API. Если вдруг имя метода API начинается со слова совпадающего с одной из команд, то можно использовать символ "<i>></i>":
<code>>Assert message $messageId is read by $user2</code>

Каждая команда или вызов метода API должны находиться на отдельной строке.
Команды регистронезависимы. assert, ASSERT или aSsErT (но зачем так писать?) будут работать.

<b>Важное замечание.</b> В неоторых случаях (команды <i>while</i>, <i>foreach</i>, <i>if</i> и <i>testcase</i>) имеет значение отступ строки для определения блока команды (привет, Python). Отступ считается как количество пробельных символов в начале строки. И пробел, и табуляция считаются за один символ, но табуляция обычно отображается в редакторах как несколько пробелов. Поэтому для избежания неразберихи лучше использовать или табы, или пробелы, но не все вместе.

<h4>Полный список команд:</h4>
<b>require <i>fileName</i></b> - подключить файл в место вызова команды. Тут же начнет выполняться подключенный файл с первой его строки. По завершению выполнения, интерпретатор вернется к следующей строке исходного файла. Если запрашиваемый файл не доступен для чтения, то будет выдана ошибка. Относительный путь считается от директории файла, в котором использована команда.

<b>include <i>fileMask</i></b> - аналогично require, но если запрашиваемый файл не доступен для чтения, то ошибки не будет. Это удобно, например, для создания настроек для разных окружений тестирования. Кроме того, include умеет подключать сразу все файлы по маске. Так, например, можно загрузить целые директории файлов, содержащих только тесткейсы. Но никакая очередность загрузки файлов не гарантируется. Относительный путь считается от директории файла, в котором использована команда.

<b>var <i>$variable1 = expression1</i>; <i>$variable2 = expression2</i>; ... ; <i>$variableN = expressionN</i></b> - установить значение переменных. Если переменной нет, она будет создана в текущем контексте.

<b>let <i>$variable1 = expression1</i>; <i>$variable2 = expression2</i>; ... ; <i>$variableN = expressionN</i></b> - установить значение переменных. Если переменной нет в текущем контексте, будет попытка создать или изменить переменную в глобальном контексте.

<b>const <i>$const1 = expression1</i>; <i>$const2 = expression2</i>; ... ; <i>$constN = expressionN</i></b> - установить значение констант в текущем контексте. Отличие констант от переменных только в том, что их нельзя изменять, при попытке присвоить значение константе после объявления будет выдана ошибка. Так же ошибка будет, если переменная с таким именем уже есть в текущем контексте. В остальном все что справедливо для переменных, справедливо и для констант.

<b>import <i>$variable1</i>; <i>$variable2</i>; ... ;<i>$variableN</i></b> - копирует переменные из глобального в текущий контекст. Может пригодиться, если надо оперировать со значением глобальной переменной, но не изменить его.

<b>testcase <i>testCaseName</i></b> - создать тест-кейс, который потом можно вызвать как единое целое командой <i>run</i>. Подробнее про <a href="#testcases">тест-кейсы</a> далее.

<b>assert <i>expression</i></b> - проверить что выражение <i>expression</i> равно <i>true</i>, в противном случае вывести отчет о провалившемся тесте.

<b>must <i>expression</i></b> - то же самое, что и <i>assert</i>, только в случае провала теста, выполнение текущего тест-кейса будет прекращено, а вне контекста тест-кейса будет вообще прекращено дальнейшее выполнение сценария. Может использоваться, если поймана ошибка, с которой дальнейшие проверки не имеют смысла.

<b>run <i>testCaseName</i></b> - запустить на выполнение заданный тест-кейс. <i>run </i> без указания имени тест-кейса запустит все доступные тест-кейсы, не требующие аргументов, в порядке их объявления.

<b>while <i>expression</i></b> - цикл, пока <i>expression</i> истинно, выполняет команды с отступом строки больше чем у <i>while</i>.

<b>foreach <i>$array</i>; <i>$element</i></b> - цикл прохода по массиву, тело цикла выполняется для каждого очередного элемента массива. Возможно получение еще и ключа <b>foreach <i>$array</i>; <i>$key</i>; <i>$element</i></b>. Переменные <i>$key</i> и <i>$element</i> создаются/перезаписываются в текущем контексте.

<b>if <i>expression</i></b> - если <i>expression</i> истинно, выполняет команды с отступом строки больше чем у <i>if</i>

<b>print <i>expression1</i>; <i>expression2</i>; ... <i>expressionN</i></b> - вывести значение выражениях <i>expressionM</i> в stdout. Может использоваться для отладки, работает только с уровнем "болтливости" <i>--verbosity=1</i> или <i>-v</i> и больше.

<b>sleep <i>expression</i></b> - сделать паузу на заданное число микросекунд. Иногда надо дать тестируемому API передышку.

<b>cancel</b> - закончить тестирование. Интерпретатор заканчивает работу, создает отчеты и т.д. Полагаю, может использоваться для отладки при запуске части сценария "вручную".

<anchor>methods</anchor><h2>Методы тестируемого API</h2>
Это собственно то, что надо тестировать - вызывать с определенными параметрами и проверять соответствует ли ответ ожиданиям.
Методы API описываются в формате YAML. Описания должны находиться в файле <i>endpoints.yaml</i> текущей директории и/или в файлах <i>*.yaml</i> в ее поддиректории <i>./endpoints</i>. Перед тестированием интерпретатор попытается вычитать сразу все эти файлы.

Пример структуры <i>endpoints.yaml</i>:
<source lang="code">
Auth $user:
    method: "POST"
    url: $domain + "/login"
    headers:
        content-type: "application/json"
    format: "json"
    data:
        login: $user.login
        password: $user.password
    after:
        - assert $response.code == 200
        - let $user.auth_token = $response.body.auth_token

Create post $post by $user:
    method: "POST"
    url: $domain + "/posts"
    format: "json"
    data: $post
    headers:
        auth: "Bearer " + $user.auth_token
        content-type: "application/json"
    after:
        - assert $response.code == 201

Read post $postId by $user:
    method: "GET"
    url: $domain + "/posts/" + $postId
    headers:
        auth: "Bearer " + $user.auth_token
        content-type: "application/json"
    after:
        - assert ($response.code == 200) || ($response.code == 404)

Create comment $comment on $post by $user:
    method: "POST"
    url: $domain + "/comments/create/" + $post.id
    format: "json"
    data: $comment
    headers:
        auth: "Bearer " + $user.auth_token
        content-type: "application/json"
    after:
        - assert $response.code == 201
</source>
На верхнем уровне структуры yaml задается имя, по которому потом метод API будет доступен для вызова. Оно представляет из себя строку в почти произвольном формате.

В любом месте имени могут быть указаны аргументы, которые будут переданы при вызове метода. Они должны быть отделены пробелами от остальных слов в имени. Например <i>$comment</i>, <i>$post</i> и <i>$user</i> в последнем методе. Значения аргументов будут переданы по ссылке из контекста, где метод API был вызван. Остальные, используемые переменные, например <i>$domain</i> в примере выше, будут взяты из глобального контекста. Подробнее <a href="#contexts">про контексты</a> расскажу дальше.

Мне кажется, удобно давать методам API человеко-понятные имена на естественном языке, тогда сценарий тестирования легче читать. Имена регистронезависимы, т.е метод <i>Auth $User</i> может быть вызван как <i>auth $User</i> и как <i>AUTH $User</i>. Однако, имена аргументов регистрозависимы, подробнее <a href="#vars">про переменные</a> ниже.

<b>Важное замечание.</b> Формат YAML позволяет не заключать строки в кавычки. Но для интерпретатора строка без кавычек - выражение, которое надо вычислить. Например объявление поля <code>url: http://example.com/login</code> приведет к синтаксической ошибке при выполнении. Поэтому правильно будет: <code>url: "http://example.com/login"</code> или <code>url: "http://"+$domain+"/login"</code>

Описание метода API состоит из следующих полей:
<i><b>method</b></i> - HTTP-метод, обязательное

<i><b>url</b></i> - собственно URL,  обязательное

<i><b>headers</b></i> - список HTTP-заголовков,  необязательное

<i><b>cookies</b></i> - список cookie,  необязательное

<i><b>query</b></i> - список параметров URL, необязательное

<i><b>format</b></i> - одно из значений <i>none</i> - у запроса нет тела, <i>json</i> - отправка в JSON, <i>form</i> -  в формате application/x-www-form-urlencoded, <i>multipart</i> - в формате multipart/form-data. Необязательное, по-умолчанию <i>none</i>

<i><b>data</b></i> - тело запроса, будет отправлено в формате заданном в <i>format</i>,  необязательное
Для формата <i>none</i> - <i>data</i> может отсутствовать, если присутствует, будет проигнорировано
Для формата <i>json</i> - любое значение
Для формата <i>form</i> - массив, ключи которого - названия полей,
<source lang="code">data:
  login: $login
  password: $password
  remember_me: 1</source>
Для формата <i>multipart</i> - массив, ключи которого - названия полей, следующей структуры:
<source lang="code">data:
    user_id:
        value: 42
        headers:
            X-Baz: "bar"
    avatar:
        file: "/path/to/file"
    photo:
        file: "http://url.to/file"
        filename: "custom_filename.jpg"</source>
Файлы, указанные в полях <i>file</i>, должны быть доступны для чтения. Если указан URL, то в php.ini должна быть включена опция <a href="http://php.net/manual/en/filesystem.configuration.php#ini.allow-url-fopen">allow_url_fopen</a>

<i><b>before</b></i> - список команд интерпретатора, которые будут выполнены до HTTP-запроса, необязательное

<i><b>after</b></i> - список команд интерпретатора, которые будут выполнены после HTTP-запроса, необязательное

Идея списков команд <i>before</i> и <i>after</i> в выполнении проверок или обработке каких-либо данных, которые нужны каждый раз до или после выполнения HTTP-запроса, и продиктованы не столько нуждами тестирования, сколько бизнес-логикой. Например, копирование выданного токена авторизации в поле структуры $user для вызова всех последующих методов API от имени этого пользователя. Или для проверки HTTP-статуса ответа.

<anchor>call</anchor><h2>Вызов метода API</h2>
Вызывается метод API очень просто, достаточно в сценарии указать его имя и, если надо, параметры. Вот пример вызова последнего метода API из описания выше:
<source lang="code">Create comment $comments.1 on $newPost by $postAuthor</source>
При каждом вызове метода API в контексте самого вызова (в списках команд <i>before</i> и <i>after</i>) и в контексте, где, он был вызван, создаются переменные <i>$request</i> и <i>$response</i>. Это зарезервированные имена, не рекомендую использовать их для других целей. <i>$request</i> доступна в обоих блоках <i>before</i> и <i>after</i>, а <i>$response</i> только в <i>after</i>, в <i>before</i> ее значение становится <i>Null</i>. В вызывающем контексте эти переменные доступны до следующего вызова метода API, где они будут заново пориницилизированы.

<h4>Структура $request</h4>
<b>$request.method</b> - тип String - HTTP-метод
<b>$request.url</b> - тип String - запрашиваемый URL
<b>$request.query</b> - тип Array - список GET-параметров
<b>$request.headers</b> - тип Array - список заголовков запроса
<b>$request.cookies</b> - тип Array - список cookies
<b>$request.format</b> - тип String - формат данных запроса
<b>$request.data</b> - тип любой - то что было вычислено в поле <i>data</i>


<h4>Структура $response</i></h4>
<b>$response.code</b> - тип Number - код ответа, например, 200 или 404
<b>$response.status</b> - тип String - статус ответа, например, "204 No Content" или "401 Unauthorized"
<b>$response.headers</b> - тип Array - список заголовков ответа
<b>$response.cookies</b> - тип Array - список cookies
<b>$response.body</b> - тип любой  - тело ответа обработанное как JSON, если была ошибка при парсинге, то элемента <i>body</i> вообще не будет: <code>@response.body == false</code> (<a href="#var_exists">о проверке существования переменных</a>)
<b>$response.raw</b> - тип String - необработанное тело ответа
<b>$response.duration</b> - тип Number - длительность запроса в секундах

При обращении к несуществующей переменной или элементу массива всегда будет остановлен сценарий тестирования и выдана ошибка. Однако, при выполнении команд <i>assert</i> или <i>must</i>, если происходит обращение к несуществующему элементу <i>$response</i>, ошибки не будет, но проверка будет считаться проваленой.

<anchor>generators</anchor><h2>Генерация моделей и тестовых данных</h2>
Генераторы служат для описания моделей и генерации тестовых данных. Описания генераторов в формате YAML будут прочитаны при запуске тестирования из файла <i>generators.yaml</i> в текущей директории и/или из всех файлов <i>*.yaml</i> в поддиректории <i>./generators</i>.

<source lang="code">User:
    body:
        login: Random\String(6, 15)
        name: Faker\Name()
        email: Faker\Email()
        password: Random\String(6, 15)
        child: child()
        tags:
            - tag1
            - tag2
        birthday: timestamp(Random\Date('1980-01-01', '1990-01-01'))
        settings:
            notifications_enabled: Random\Boolean()

Child:
    body:
        name: Faker\name()
        gender: Random\Integer(1, 2)
        age: Random\Integer(0, 18)

Comment($user):
    body:
        content: "Hi! I'm " + $user.name
</source>
В примере выше объявлено три генератора <i>User()</i>, <i>Child()</i> и <i>Comment()</i>. При этом последний имеет аргумент <i>$user</i> и может использовать эти данные при генерации. Аргументы в генераторы всегда передаются по значению. Кроме того, в примере используются еще несколько встроенных функций: <i>Random\String()</i>, <i>Faker\Name()</i>, <i>Faker\Email()</i> и т.д. О встроенных функциях <a href="#functions">расскажу ниже</a>.

При вызове генератора <i>User()</i> из примера выше будет сгенерирована структура, которая в JSON выглядит примерно так:
<source lang="json">{
  "login": "fgadrkq",
  "name": "Lucy Cechtelar",
  "email": "tkshlerin@collins.com",
  "password": "gbnaueyaaf",
  "child": {
    "name": "Adaline Reichel",
    "gender": 2,
    "age": 12
  },
  "tags": [
    "tag1",
    "tag2"
  ],
  "birthday": 318038400,
  "settings": {
    "notifications_enabled": true
  }
}
</source>
При генерации поля <i>child:</i> будет вызван генератор <i>Сhild()</i>, и результат его работы будет добавлен в поле.
Как и в описании методов API, любые строки, не заключенные в кавычки, рассматриваются как выражения, которые будут вычислены. Это может быть не только вызов другого генератора, а произвольное выражение, например, в генераторе <i>Comment($user)</i> поле <i>content</i> представляет конкатенацию строки "Hi! I'm " и имени переданного <i>$user</i>

Имена генераторов регистронезависимы и должны начинаться с латинской буквы, могут содержать в себе латинские буквы, цифры, подчеркивание и обратный слеш.
Поскольку синтаксис вызова генераторов и встроенных функций одинаков, они делят общее пространство имен. Обратный слеш я предлагаю по соглашению использовать в качестве разделителя для указания "вендора" или библиотеки встроенных функций, как например функции Faker\something(), основанные на библиотеке https://github.com/fzaninotto/Faker.

При помощи генераторов можно компановать  структуры:
<source lang="code">
# UserСredentials основана на данных из $user
UserСredentials($user):
    body:
        login: $user.email
        password: $user.password

# Примерная структура ответа соц. сети на поиск по постам, комментам и пользователям
GlobalSearchResult($posts, $comments, $users):
    body:
        posts:
            title: "Найденные посты"
            list: $posts
        comments:
            title: "Найденные комментарии"
            list: $comments
        users:
            title: "Найденные пользователи"
            list: $users
</source>
<i>GlobalSearchResult</i> представляет собой не тестовые данные, которые посылаются в запросе к методу API, а модель ответа, которую можно сверить с тем, что пришлет API, например, использованием функций <a href="#functions"><i>similar()</i></a> или <a href="#functions"><i>identical()</i></a>.

Генератор может изменять структуру получаемую в <i>body</i> с помощью структур вычисляемых в полях <i>replace</i> и <i>remove</i>. Лучше покажу на примере.

Допустим, уже есть генератор <i>User()</i>, который создает правильную структуру данных для пользователя. Теперь надо проверить как API будет реагировать, если представить неправильные данные. Можно пойти двумя путями:
- Создать генератор "неправильного" пользователя с нуля. Но тогда, при добавлении пользователю нового поля по нуждам бизнес-логики, придется вносить правки уже в два места. DRY!
- Можно "отнаследоваться" от уже имеющейся структуры User(), задав его в <i>body</i>. А в <i>replace</i> и <i>remove</i> задать, поля которые будут добавлены/изменены и удалены.
<source lang="code">
# Вернет структуру как у переданного пользователя, но изменит два поля,
# сделав его невалидным для проверки этапа регистрации
InvalidUser($user):
    body: $user
    replace:
        email: Faker\String(6, 15) # Неавлидный емейл
        password: Faker\String(1, 5) # Слишком короткий пароль
        new_field: "этого поля у правильного пользователя не было, теперь будет"

# А так можно сгенерировать случайного пользователя,
# а потом изменить или удалить пару  полей
InvalidNewUser:
    body: User()
    replace:
        login: "!@#$%^&*" # Невалидный логин
    remove:
        about: true
        settings:
            notifications: 100500 # Неважно какое именно значение будет у поля,
                                  # главное чтоб оно было объявлено
</source>

При использовании полей <i>replace</i> и <i>remove</i> сначала вычисляется структура в <i>body</i>, а потом перезаписываются и дополняются элементами из <i>replace</i> и потом удаляются поля указанные в <i>remove</i>. Если результат вычисления <i>body</i>, <i>replace</i> или <i>remove</i> не массивы, то ошибки не будет, но и смысла в этом никакого нет, т.к не будет полей которые можно было бы заменить и удалить.

<anchor>functions</anchor><h2>Встроенные функции</h2>
Встроенные функции предназначены в первую очередь для генерации тестовых данных, как и генераторы, и для небольших манипуляций с данными.

Вот тут <a href="https://github.com/maximw/PieceofScript/wiki/Internal-functions">полный список встроенных функций</a>. Для примера приведу только некоторые из них.
После имени функции и списка аргументов указан <a href="#types">тип</a> возвращаемого значения, если он определен.

<h4>Операции с переменными:</h4>
<b>similar</b>($var, $sample) <i>Boolean</i> - возвращает <i>true</i>, если аргументы имеют одинаковый тип, если <i>$var</i> - массив, то все строковые ключи, которые есть в <i>$sample</i>, должны быть в <i>$var</i>, при этом типы соответсвующих элементов должны совпадать. Другими словами, элементы массива <i>$var</i> являются подмножеством элементов <i>$sample</i>.
<b>identical</b>($var, $sample) <i>Boolean</i> - аналог <i>similar()</i>, с дополнительным обрантым условием, в случае массивов, все строковые ключи в <i>$var</i> должны быть и в <i>$sample</i>. Другими словами элементы массива <i>$var</i> равны элементам массива <i>$sample</i> с точностью до типа элемента.
<b>max</b>($var1, $var2, ... $varN)  - максимальное из переданных значений (если они поддаются сравнению).
<b>min</b>($var1, $var2, ... $varN)  - минимальное из переданных значений.

<h4>Работа со строками:</h4>
<b>size</b>($string) <i>Number</i> - длина строки в кодировке UTF-8.
<b>regex</b>($string, $regex) <i>Boolean</i> - проверка строки на <a href="http://php.net/manual/en/pcre.pattern.php">регулярное выражение</a>.
<b>regexMatch</b>($string, $regex) <i>Array</i> - вернет массив строк - совпадений с группами регулярки <i>$regex</i>.

<h4>Обработка массивов:</h4>
<b>array</b>($var1, $var2, ... $varN) <i>Array</i> - создаст массив из переданных элементов.
<b>size</b>($array) <i>Number</i> - количество элементов массива.
<b>keys</b>($array) <i>Array</i> - список ключей массива.
<b>slice</b>($array, $offset, $length) <i>Array</i> - часть массива от $offset длиной $length, (<a href="http://php.net/manual/en/function.array-slice.php">подробнее</a>).

<h4>Обработка дат:</h4>
<b>dateFormat</b>($date, $format) <i>String</i> - форматирование даты, (<a href="http://php.net/manual/en/datetime.formats.php">подробнее</a>).

<h4>Генерация случайных тестовых данных:</h4>
<b>Random\Date</b>($min, $max, $withTime) <i>Date</i> - случайная дата от $min до $max включительно, если $withTime = true, то будет и случайное время, иначе полночь.
<b>Random\Choice</b>($value1, $weight1, $value2, $weight2,...  $valueN, $weightN) - можно передать любое четное количество аргументов, вернет $valueN c вероятностью  $weightN / "сумма всех весов"
<b>Faker\Integer</b>($min, $max) <i>Number</i> - случайное целое от $min до $max включительно
<b>Faker\Char</b>($min, $max) <i>String</i> - случайный символ от $min до $max включительно
<b>Faker\String</b>($min, $max) <i>String</i> - случайную строку из символов a-z дилной от $min до $max включительно
<b>Faker\Name</b>() <i>String</i> - случаное имя
<b>Faker\Email</b>() <i>String</i> - случайный email

Сейчас этот список довольно скуден. Я добавил только то, что мне кажется будет необходимым при тестировании, не хочу слишком перегружать язык. Добавлять новые функции можно по мере необходимости в новых версиях. А будущем, если будет востребовано, добавлю возможность создавать динамически-подключаемые функции, реализованные в виде специальных классов на PHP.

<anchor>testcases</anchor><h2>Тест-кейсы</h2>
Тест-кейс это последовательность команд, которая может быть вызвана как единое целое.
Создание тест-кейса начинается с команды <i>testcase</i> за которой следует имя тест-кейса, с требованиями как у имен <a href="#methods">методов API</a>.

<source lang="code">testcase Registration $device
   //Тест на регистрацию валидного пользователя
   var $user = User()
   Register $user on $device
   assert $response.code == 201

   //Тест на регистрацию пользователя с неправильной электронной почтой
   var $user = User() // хотя можно было бы сделать генератор InvalidUser()
   var $user.email = "some_bad_email"
   Register $user on $device
   assert $response.code == 400
</source>
Все команды, у которых отступ начала строки больше чем у строки с командой <i>testcase</i>, считаются принадлежащими тесткейсу. Они будут выполнены не сразу, а после запуска тест-кейса командой <i>run</i>. В контексте тест-кейса нельзя использовать <i>testcase</i>, т.е. вложенные тест-кейсы запрещены.

<i>run</i> может вызвать отдельный тест-кейс, либо все тест-кейсы, которые не требуют аргументов.
<source lang="code">
run Get all users     // Запуск отдельного тест-кейса, не требующего аргументов
run Get user $user_id // Запуск отдельного тест-кейса с аргументом
run                   // Запуск всех тесткейсов, которые не требуют аргументов
</source>
Идея в том, что тест-кейсы можно использовать как отдельные независимые наборы проверок части бизнес-логики, либо как часть для более сложного сценария, где может потребоваться передача данных из вызывающего контекста.

В пером случае достаточно подключить все файлы содержащие тесткейсы, и запустить их одной командой <i>run</i>.
Во втором каждый тест-кейс должен вызываться отдельно. И поскольку тест-кейс предполагается частью сценария, аргументы передаются по ссылке, т.е. значения переменных могут быть изменены и в вызывающем контексте. Разумеется, можно смешивать оба этих подхода.

<anchor>vars</anchor><h2>Переменные и области видимости</h2>
Имена переменных регистрозависимы и начинаются со знака <i>$</i> (да-да, я пхпшник), далее должна следовать латинская буква, далее латинские буквы, подчеркивание <i>_</i> или цифры.

Если значение переменной типа <i>Array</i>, то доступ к отдельным полям или элементам значения производится через точку: <code>$users.12.password</code>. Между точками допускаются либо только цифры, либо латинские буквы, подчеркивания и цифры с первой латинской буквой. Имена полей тоже регистрозависимы.
Возможно динамическое обращение к элементу массива: <code>$post.comments[$i + 1].content</code>

<anchor>contexts</anchor>Есть четыре типа контекстов - областей видимости переменных.

<b>Глобальный контекст</b> - создается на старте, содержит все переменные объявленные при выполнении команд вне тест-кейсов.

<b>Контекст тест-кейса</b> - создается новый при каждом выполнении тест-кейса командой <i>run</i>. Переменные в контекст тест-кейса передаются по ссылке.

<b>Контекст метода API</b> - создается при вызове метода API, при выполнении команд, указанных в секциях <i>before</i> и <i>after</i>. Переменные в контекст метода API передаются по ссылке.

<b>Контекст генератора</b> - в генераторах нет возможности создания новых или изменения существующих переменных, поэтому доступны только для чтения переменные глобального контекста и аргументы. Если в выражениях при выполнени генератора будет встречена оперция присваивания <i>=</i>, будет выдана ошибка. Переменные в контекст генератора передаются по значению.

<b>Важное замечание.</b> Внутри всех контекстов доступны переменные глобального контекста, если в текущем контексте не объявлены их "тезки" командами <i>var</i>, <i>const</i> или <i>import</i>.

Примеры команд работы с переменными:
<source lang="code">const $a = 1
let $a = 2 // Будет выдана ошибка
var $b = 1
const $b = 3 // Будет выдана ошибка
const $c = 3; $c = 4 // Будет выдана ошибка, $c уже определно в первой секции
</source>
<source lang="code">let $a = 1; $a = $a + 1; $a = $a + 2
print $a // 4
</source>
<source lang="code">Testcase Context example changes $argument1 and $argument2
   var $a = "changed"
   let $b = "changed"
   const $c = "changed"
   import $i
   let $i = "changed"
   var $argument = "changed"
   var $argument2 = "changed" // Будет выдана ошибка, по ссылке передали константу

var $a = "original"
var $b = "original"
var $i = "original"
const $c = "original";
var $param = "original"
const $constParam = "original"

run Context example changes $param and $constParam

// новая $a была создана в контексте тест-кейса
print $a // "original"

//  $b не было в контексте тест-кейса, и let обратился к глобальной $b
print $b // "changed"

// $i была импортирована из глобального контекста
print $i // "original"

// константы создаются в каждом контексте свои, аналогично var создает переменные
print $c // "original"

// параметры передаются по ссылке
print $param // "changed"
</source>

<anchor>types</anchor><h2>Система типов и операции</h2>
Используется нестрогая динамическая типизация.
Значения хранятся в "обертках" над соответсвтующими типами PHP.  Для лучшего понимания можно <a href="http://php.net/manual/en/language.types.php">ознакомиться</a> системой типов PHP. Я сделал немного меньше свободы в динамическом преобразовании типов. Например, при сложеннии строки и числа <code>"2" + 2</code>, будет выдана ошибка, а PHP спокойно выполнит сложение. Возможно мне нужно будет пересмотреть правила динамической типизации в будущем, но пока, я попытался найти баланс между удобством и строгостью, необходимой для надежных тестов.

Типы данных, доступные в PieceofScript:

<b><a href="https://github.com/maximw/PieceofScript/wiki/Numbers">Number</a></b> - число. Из соображений простоты я не стал делать отдельные типы для Integer и Float. Единственное существенное отличие целых и вещественных чисел в PieceofScript - использование в качестве ключей массива: вещественные числа будут округлены до целых.
<code>7 -42 3.14159</code>

<b><a href="https://github.com/maximw/PieceofScript/wiki/Strings">String</a></b> - строки, заключенные в двойные кавычки, возможно экранирование слешем
<code>"I say \"Hello world!\""</code>

<b><a href="https://github.com/maximw/PieceofScript/wiki/Null">Null</a></b> - задается регистронезависимой константой
<code>null</code>

<b><a href="https://github.com/maximw/PieceofScript/wiki/Booleans">Boolean</a></b> - является результатом булевых операций и операций сравнения, задается регистронезависимыми константами
<code>true false</code>

<b><a href="https://github.com/maximw/PieceofScript/wiki/Dates">Date</a></b> - дата и время. "Под капотом" это <a href="http://php.net/manual/en/class.datetime.php">DateTime</a>. Константы задаются в одинарных кавычках, в одном из <a href="http://php.net/manual/en/datetime.formats.php">форматов</a>.
<code>'now', '2008-08-07 18:11:31', 'last day of next month'</code>

<b><a href="https://github.com/maximw/PieceofScript/wiki/Arrays">Array</a></b> - массив, единственный не скалярный тип. Обертка над <a href="http://php.net/manual/en/language.types.array.php">Array</a>. Литералов этого типа нет, но массивы могут быть результатом работы генераторов, встроенных функций (например, <i>array()</i> - привет PHP 5.3 и ниже), или можно просто обращаться к ключам переменных, которые по возможности будут динамически создаваться при присвоении.
<code>let $a.1 = 100
let $i = 1
let $a[$i + 1] = 200
let $a.sum = $a.1 + $a.2
print "Сумма "; $a.sum // 300
var $b = array(true, 3, $a, "Hi") // [true, 3, $a, "Hi"]
</code>
Набор операций довольно стандартен - арифметические, сравнения, булевые.
Подробно про доступные операции, как они работают с операндами разных типов, и про конвертацию типов  друг в друга можно прочитать здесь https://github.com/maximw/PieceofScript/wiki .

<anchor>var_exists</anchor><h4>Проверка существования и типа переменной</h4>
Отдельно надо упомянуть констукцию проверки существования и типа переменной <b><i>@</i></b>.
Если в имени переменной вместо <i>$</i> указать <i>@</i>, то результатом работы этой конструкции будет одно из:
- строка с именем типа переменной или типа элемента массива, если использовались ключи;
- <i>false</i>, если переменная не найдена в доступных контекстах или элемента с указанным ключем в массиве не существует.
Эта конструкция может быть удобна при проверках структуры HTTP-ответов. Например при таком ответе:
<source lang="json">{
  "string_field": "Hello World", // @response.body.string_field == "String"
  "number_field": 3.14,          // @response.body.number_field == "Number"
  "bool_field": true,            // @response.body.bool_field == "Boolean"
  "array_field": [               // @response.body.array_field == "Array"
    1,
    2,
    3                            // @response.body.array_field.2 == "Number"
                                 // @response.body.array_field.3 == false
  ],
  "null_field": null             // @response.body.null_field == "Null"
                                 // @response.body.any_other_field == false
}</source>
Или в конструкциях типа:
<source lang="code">assert @comment.optional_field && $comment.optional_field > 20</source>
Булевые операции оптимизированы по первому операнду. Если первый операнд равен <i>false</i>, то операция <i>&&</i> даже не будет пытаться вычислить второй операнд. Аналогично с <i>||</i>.

<anchor>output</anchor><h2>Вывод в stdout</h2>
Различная информация работы интерпретатора выводится в stdout. После завершения отчет может быть сформирован в формате JUnit, если при запуске в командной строке была указана опция <code>--junit-report</code>

Есть 5 стандартных уровней вывода информации. Все что выводится на одном уровне, выводится и на остальных более "болтливых".

<b>Quiet</b> - самый "молчаливый" уровень задается опцией командной строки <b>-q</b>.
На этом уровне ничего не выводится в stdout, даже критические ошибки интерпретатора. Но по ненулевому коду возврата, можно понять, что что-то пошло не так.

<b>Normal</b> - это уровень по-умолчанию, без задания опций.
На этом уровне выводятся ошибки в работе интепретатора. Ошибочные запросы к методам API и провалившиеся проверки <i>assert</i> и <i>must</i>.

<b>Verbose</b> - задается опцией <b>-v</b>.
На этом уровне выводятся результаты работы команды <i>print</i>.

<b>Very verbose</b> - задается опцией <b>-vv</b>.
На этом уровне выводятся предупреждения интерпретатора.

<b>Debug</b> - задается опцией <b>-vvv</b>.
На этом уровне выводятся все выполняемые строки сценария. Все запросы и ответы методов API, результаты работы всех проверок <i>assert</i> и <i>must</i>.

<anchor>todo</anchor><h2>Пример тестирования приложения TODO-лист</h2>
Пословица "Лучше один раз увидеть, чем сто раз услышать" справедлива в интерпретации "лучше один раз увидеть код, чем сто раз прочитать его описание".

Для примера подготовил примитивное API для работы с TODO-листами, и сценарии тестирования для него, как я вообще вижу и задумывал применение PieceofScript. Можно скачать и "потрогать своими руками":
Репозиторий TODO-листа
Swagger-описание API

<anchor>plans</anchor><h2>Замечания и планы на будущее, если оно будет</h2>
<b>1)</b> Сейчас не очень хорошо реализован парсинг вызовов методов API и запуска тест-кейсов. Там или нужен полноценный лексер, или придется отказаться от свободного формата именования в ущерб читабельности. Возможны проблемы с парсингом передаваемых параметров, поэтому не стоит в вызове передавать уж слишком сложные выражения. Кроме того, нельзя передавать литералы, ну это очевидно, т.к. в обоих случаях, и методов API, и тест-кейсов, передача идет по ссылке.

<b>2)</b> Думаю, очень полезным будет возможность скаффолдинга для методов API на основе описания в OpenAPI (<a href="https://swagger.io/">Swagger</a>), <a href="https://raml.org">RAML</a>, коллекций <a href="https://www.getpostman.com">Postman</a>. Но это большая работа, за которую стоит сесть, если PieceofScript того стоит. Буду проверять на своей "шкуре", поэтому скаффолдинг первоочередная задача.

<b>3)</b> Хорошо было бы сделать плагин(ы) для некоторых IDE, с подсветкой кода и автодополнением. Автодополнение имен тест-кейсов, методов API, команд и переменных было бы просто архиудобно. Но еще "копал" в этом направлении. Разбираюсь с созданием подсветки для Sublime Text.

<b>4)</b> Не знаю в какой приоритет поставить возможность создания динамически подключаемых <a href="#functions">функций</a>, реализованных на PHP. С одной стороны там все просто, достаточно разобраться с автозагрузкой и сделать спецификацию используемых классов и неймспейсов. С другой стороны сложные функции со своими зависимостями неминуемо вызовут конфилкт неймспейсов у зависимостей (в худшем случае еще и разных версий). Тут тоже есть над чем думать.

<b>5)</b> Хорошие системы тестирования запускают независимые тесты параллельно. Сейчас это можно сделать запустив несколько раз <i>pos.phar</i> с разными стартовыми файлами, где подключаются разные тест-кейсы. Но я думаю, надо встроить это в сам интерпретатор с автоматическим определением того, что может быть запущего параллельно.

P.S. С одной стороны, поскольку это моя "поделка", логично было бы засунуть пост в хаб "Я пиарюсь". С другой стороны, я не пиаюсь, просто инструмент который, делал "для себя", решил причесать и выложить публично. Но в любом случае по ограничениям Хабра не могу писать в хаб "Я пиарюсь".